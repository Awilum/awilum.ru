<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Статьи | awilum.ru</title><description>Про разработку программного обеспечения, образование и IT в целом.</description><link>https://awilum.ru/</link><item><title>Генерация случайных чисел с фокусом на диапазоне в JavaScript</title><link>https://awilum.ru/articles/range-focused-random-number-generation-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/range-focused-random-number-generation-in-javascript/</guid><description>Генерация случайных чисел с фокусом на диапазоне в JavaScript</description><pubDate>Sat, 09 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
Генерация случайных чисел в **JavaScript** может быть выполнена с использованием встроенных методов и функций языка. Для генерации случайных чисел в определенном диапазоне в JavaScript можно воспользоваться следующими методами.

### Math.random() 

Этот метод возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (исключительно). Для получения числа в определенном диапазоне, например, от 0 до 10, можно использовать следующий подход:

```javascript
// Генерация числа от 0 до 10
let randomNumber = Math.random() * 10;

console.log(randomNumber);
```

Однако этот метод вернет число с плавающей точкой, и оно не будет целым.

### Math.floor() или Math.ceil()

Для округления числа можно использовать `Math.floor()` или `Math.ceil()`. `Math.floor()` округляет число вниз до ближайшего целого, а `Math.ceil()` округляет число вверх до ближайшего целого.

```javascript
// Генерация целого числа от 0 до 9
let randomNumber = Math.floor(Math.random() * 10);

console.log(randomNumber);
```

### Генерация числа в определенном диапазоне

Для генерации случайного числа в заданном диапазоне [min, max] можно воспользоваться формулой:

```javascript
let min = 5;
let max = 15;

// Генерация целого числа от 5 до 15 включительно
let randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
```

В данной формуле:

- `Math.random()` генерирует число от 0 до 1 (не включительно).
- `(max - min + 1)` задает диапазон чисел, которые можно получить.
- `Math.floor()` округляет число вниз до ближайшего целого.
- `+ min` смещает результат так, чтобы он попадал в заданный диапазон [min, max].

&lt;br&gt;&lt;br&gt;

Таким образом, при помощи этих методов можно генерировать случайные числа в JavaScript в заданном диапазоне.</content:encoded></item><item><title>Округление чисел в JavaScript</title><link>https://awilum.ru/articles/rounding-numbers-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/rounding-numbers-in-javascript/</guid><description>Округление чисел в JavaScript</description><pubDate>Sat, 09 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
Округление чисел в **JavaScript** можно выполнять различными способами, в зависимости от требуемой точности и правил, которые нужно применить.

### Math.round()

Этот метод округляет число до ближайшего целого числа. При дробной части равной 0.5, число округляется к ближайшему четному числу.

Пример:

```javascript
console.log(Math.round(4.4)); // 4
console.log(Math.round(4.5)); // 5
```

### Math.floor()

Округляет число вниз до ближайшего меньшего целого числа.

Пример:

```javascript
console.log(Math.floor(4.9)); // 4
```

### Math.ceil()

Округляет число вверх до ближайшего большего целого числа.

Пример:

```javascript
console.log(Math.ceil(4.1)); // 5
```

### toFixed()

Этот метод возвращает строковое представление числа с указанным количеством знаков после запятой.

Пример:

```javascript
let num = 5.6789;

console.log(num.toFixed(2)); // 5.68
```

&lt;br&gt;

Каждый из этих методов имеет свои особенности и подходит для разных сценариев. Выбор метода зависит от конкретной задачи и требуемого результата.</content:encoded></item><item><title>Как определить операционную систему пользователя в JavaScript</title><link>https://awilum.ru/articles/how-to-detect-the-users-operating-system-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-detect-the-users-operating-system-in-javascript/</guid><description>Как определить операционную систему пользователя в JavaScript</description><pubDate>Fri, 08 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
В **JavaScript** существует несколько способов определить операционную систему пользователя. 

### navigator.platform

Это свойство объекта navigator, который предоставляет информацию о браузере пользователя. Оно возвращает строку, представляющую платформу, на которой запущен браузер. Например, если пользователь использует Windows, значение будет &quot;Win32&quot; или &quot;Win64&quot;. Если это macOS, значение будет &quot;MacIntel&quot;, &quot;MacPPC&quot; или &quot;Mac68K&quot;. Если это Linux, то значение будет &quot;Linux i686&quot; или &quot;Linux x86_64&quot;.

Пример:

```javascript
let platform = navigator.platform;

console.log(platform);
```

### navigator.userAgent

Это еще одно свойство объекта `navigator`, которое возвращает строку с информацией о браузере пользователя. С помощью регулярных выражений можно проверить эту строку на наличие ключевых слов, указывающих на операционную систему пользователя.

Пример:

```javascript
let userAgent = navigator.userAgent;

if (userAgent.match(/Windows/i)) {
    console.log(&quot;Пользователь использует Windows.&quot;);
} else if (userAgent.match(/Macintosh/i)) {
    console.log(&quot;Пользователь использует macOS.&quot;);
} else if (userAgent.match(/Linux/i)) {
    console.log(&quot;Пользователь использует Linux.&quot;);
} else {
    console.log(&quot;Не удалось определить операционную систему пользователя.&quot;);
}
```

### window.navigator.platform и window.navigator.userAgentData

Начиная с более новых версий **JavaScript** и браузеров, можно использовать свойства `platform` и `userAgentData` объекта `navigator` для получения информации об операционной системе пользователя. Это более надежные и точные способы определения.

Пример:

```javascript
let platform = window.navigator.platform;
let userAgentData = window.navigator.userAgentData;

console.log(&quot;Platform:&quot;, platform);
console.log(&quot;User Agent Data:&quot;, userAgentData);
```

&lt;br&gt;

Эти методы позволяют определить операционную систему пользователя на основе данных, предоставленных браузером. Однако стоит помнить, что пользователи могут изменять настройки браузера или использовать специализированные программы для скрытия своей операционной системы, поэтому результаты могут быть не всегда точными.</content:encoded></item><item><title>Определение размеров окна браузера в JavaScript</title><link>https://awilum.ru/articles/determining-browser-window-sizes-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/determining-browser-window-sizes-in-javascript/</guid><description>Определение размеров окна браузера в JavaScript</description><pubDate>Thu, 07 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
В **JavaScript** для определения размеров окна браузера вы можете использовать свойства объекта **window**. Эти свойства предоставляют информацию о размерах окна браузера, а также другие полезные сведения. 

Вот основные свойства, которые вы можете использовать:

### innerWidth и innerHeight

Эти свойства предоставляют ширину и высоту внутренней области окна браузера, которая включает в себя содержимое страницы и исключает браузерные элементы, такие как панель инструментов и полосы прокрутки.

### outerWidth и outerHeight

Эти свойства предоставляют ширину и высоту всего окна браузера, включая браузерные элементы, такие как панель инструментов и рамку окна.

### document.documentElement.clientWidth и document.documentElement.clientHeight

Эти свойства также предоставляют ширину и высоту внутренней области окна браузера, но они могут быть полезны, когда объект **window** недоступен, например, в ситуациях, когда скрипт выполняется в **iframe**.

### document.documentElement.offsetWidth и document.documentElement.offsetHeight

Эти свойства возвращают ширину и высоту всего содержимого документа включая область за пределами видимой части окна, если содержимое прокручено.

Пример использования:

```javascript
// Получение размеров окна браузера
let windowWidth = window.innerWidth || document.documentElement.clientWidth;
let windowHeight = window.innerHeight || document.documentElement.clientHeight;

let outerWindowWidth = window.outerWidth;
let outerWindowHeight = window.outerHeight;

// Вывод информации в консоль
console.log(&quot;Inner width: &quot; + windowWidth + &quot;, Inner height: &quot; + windowHeight);
console.log(&quot;Outer width: &quot; + outerWindowWidth + &quot;, Outer height: &quot; + outerWindowHeight);
```

Обратите внимание, что значения свойств могут быть недоступными или неопределенными в некоторых случаях, например, если скрипт выполняется в контексте **iframe** или если браузер заблокировал доступ к свойствам окна в целях безопасности.</content:encoded></item><item><title>Как определить темный режим с помощью JavaScript</title><link>https://awilum.ru/articles/how-to-detect-dark-mode-using-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-detect-dark-mode-using-javascript/</guid><description>Как определить темный режим с помощью JavaScript</description><pubDate>Wed, 06 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
Обнаружение темной темы (dark mode) с помощью **JavaScript** можно осуществить, используя функциональность медиа-запросов **CSS** и свойства **window.matchMedia**. Это позволяет вашему веб-сайту или веб-приложению реагировать на изменения темы, которые сделал пользователь в настройках своего устройства или браузера.

Вот пример кода, который демонстрирует, как это можно сделать:

```javascript
// Функция для проверки, включен ли темный режим
function isDarkModeEnabled() {
  // Создаем медиа-запрос для проверки темной темы
  const darkModeQuery = window.matchMedia(&apos;(prefers-color-scheme: dark)&apos;);
  
  // Возвращаем результат проверки текущего состояния медиа-запроса
  return darkModeQuery.matches;
}

// Пример использования
if (isDarkModeEnabled()) {
  // Если включен темный режим
  console.log(&apos;Темный режим включен&apos;);
} else {
  // Если темный режим выключен
  console.log(&apos;Темный режим выключен&apos;);
}

// Добавляем обработчик событий для изменения состояния темы
window.matchMedia(&apos;(prefers-color-scheme: dark)&apos;).addEventListener(&apos;change&apos;, (e) =&gt; {
  if (e.matches) {
    // Если переключились на темный режим
    console.log(&apos;Темный режим включен&apos;);
  } else {
    // Если переключились на светлую тему
    console.log(&apos;Темный режим выключен&apos;);
  }
});
```

Этот код включает обработку изменения темы в реальном времени, реагируя на событие **change** в медиа-запросе. Таким образом, когда пользователь изменяет тему на своем устройстве или браузере, ваше веб-приложение будет автоматически обновляться и соответствовать выбранной теме.</content:encoded></item><item><title>Как удалить первый символ строки в JavaScript</title><link>https://awilum.ru/articles/how-to-remove-the-first-character-of-a-string-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-remove-the-first-character-of-a-string-in-javascript/</guid><description>Как удалить первый символ строки в JavaScript</description><pubDate>Wed, 06 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
Чтобы удалить первый символ из строки в **JavaScript**, можно использовать несколько различных способов. 

### Использование метода `substring()`

Метод `substring()` позволяет вырезать подстроку из строки по указанным индексам. Мы можем использовать этот метод, указав начальный индекс как 1 (что соответствует второму символу) и конечный индекс, равный длине строки.

```javascript
let str = &quot;example&quot;;

str = str.substring(1);

console.log(str); // &quot;xample&quot;
```

### Использование метода `slice()`

Метод `slice()` также позволяет вырезать подстроку из строки. Мы можем использовать его, указав начальный индекс как 1 (опять же, соответствует второму символу).

```javascript
let str = &quot;example&quot;;

str = str.slice(1);

console.log(str); // &quot;xample&quot;
```

### Использование метода `substr()`

Метод `substr()` позволяет выбирать подстроку начиная с определенного индекса и указывая количество символов. Мы можем использовать его, указав начальный индекс как 1 и количество символов равным длине строки минус один.

```javascript
let str = &quot;example&quot;;

str = str.substr(1);

console.log(str); // &quot;xample&quot;
```

&lt;br&gt;

Все эти методы выполняют одно и то же действие - удаляют первый символ из строки и возвращают измененную строку. Выбор метода зависит от предпочтений и конкретных требований вашего проекта.</content:encoded></item><item><title>Разбиение строк на слова в JavaScript</title><link>https://awilum.ru/articles/splitting-strings-into-words-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/splitting-strings-into-words-in-javascript/</guid><description>Разбиение строк на слова в JavaScript</description><pubDate>Tue, 05 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
Для разбиения строки на слова в **JavaScript** можно воспользоваться различными методами. Один из наиболее распространенных способов - использовать метод `split()`. 

```javascript
// Исходная строка
let str = &quot;Пример строки для разбиения на слова&quot;;

// Разбиваем строку на массив слов, используя пробел в качестве разделителя
let wordsArray = str.split(&quot; &quot;);

// Теперь массив wordsArray содержит отдельные слова из исходной строки
console.log(wordsArray);

// [ &apos;Пример&apos;, &apos;строки&apos;, &apos;для&apos;, &apos;разбиения&apos;, &apos;на&apos;, &apos;слова&apos; ]
```

Этот код разобьет исходную строку на массив слов, разделенных пробелами.

Для исключения знаков пунктуации в словах можно воспользоваться регулярным выражением, которое будет учитывать только буквенные символы. 

Вот как это можно сделать:

```javascript
// Исходная строка
let str = &quot;Пример, строки! с? знаками: препинания.&quot;;

// Разбиваем строку на массив слов, используя регулярное выражение
let wordsArray = str.match(/[а-яА-ЯёЁ]+/g);

// Теперь массив wordsArray содержит отдельные слова из исходной строки без знаков пунктуации
console.log(wordsArray);

// [ &apos;Пример&apos;, &apos;строки&apos;, &apos;с&apos;, &apos;знаками&apos;, &apos;препинания&apos; ]
```

В этом примере мы используем регулярное выражение `/[а-яА-ЯёЁ]+/g`, которое соответствует русским словам (включая буквы и символы &quot;ё&quot; и &quot;Ё&quot;) и исключает знаки пунктуации.</content:encoded></item><item><title>Руководство по стилю написания кода на JavaScript</title><link>https://awilum.ru/articles/javascript-coding-style-guide/</link><guid isPermaLink="true">https://awilum.ru/articles/javascript-coding-style-guide/</guid><description>Руководство по стилю написания кода на JavaScript</description><pubDate>Mon, 04 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
Придерживаться руководства по стилю написания кода на &lt;strong&gt;JavaScript&lt;/strong&gt; имеет несколько важных преимуществ:

&lt;ol&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Улучшает читаемость кода.&lt;/strong&gt;&lt;br /&gt;
	Хорошо оформленный и согласованный стиль кода делает его более понятным и удобочитаемым для других разработчиков. Когда несколько человек работают над проектом, каждый может иметь свой собственный стиль написания кода, что может затруднить взаимопонимание. Руководство по стилю помогает установить общие правила, которые все разработчики будут использовать, что упрощает понимание и сотрудничество.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Помогает избежать ошибок.&lt;/strong&gt;&lt;br /&gt;
	Руководство по стилю написания кода может содержать рекомендации по использованию определенных конструкций языка, которые могут помочь избежать ошибок или недочетов в коде.&amp;nbsp;&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Снижает вероятность конфликтов в коде.&lt;/strong&gt;&lt;br /&gt;
	Если разработчики используют разные стили написания кода, это может привести к конфликтам и ошибкам при объединении кода. Руководство по стилю помогает избежать таких проблем, устанавливая общие правила и рекомендации для всех разработчиков.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Улучшает производительность и поддержку кода.&lt;/strong&gt;&lt;br /&gt;
	Хорошо оформленный код легче читать и понимать, что может сделать его более эффективным в работе и проще в поддержке. Руководство по стилю&amp;nbsp;содержит&amp;nbsp;рекомендации по оптимизации кода и снижению его сложности, что может привести к улучшению его производительности и упрощению его поддержки.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Повышает профессионализм разработчиков.&lt;/strong&gt;&lt;br /&gt;
	Руководство по стилю написания кода является одним из признаков профессионализма разработчика. Когда разработчики используют общепринятые стандарты и рекомендации, это может повысить доверие к их работе и улучшить репутацию компании в глазах заказчиков и пользователей.&lt;/p&gt;
	&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Вот некоторые популярные руководства по стилю написания кода на JavaScript:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://google.github.io/styleguide/javascriptguide.xml&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;Google JavaScript Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/airbnb/javascript&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;Airbnb JavaScript Style Guide&lt;/a&gt;&amp;nbsp;(ru:&amp;nbsp;&lt;a href=&quot;https://leonidlebedev.github.io/javascript-airbnb/&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;перевод&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rwaldron/idiomatic.js&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;Idiomatic.JS&lt;/a&gt;&amp;nbsp;(ru:&amp;nbsp;&lt;a href=&quot;https://github.com/rwaldron/idiomatic.js/tree/master/translations/ru_RU&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;перевод&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://standardjs.com/&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;StandardJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content:encoded></item><item><title>Как получить текущую метку времени в JavaScript</title><link>https://awilum.ru/articles/how-to-get-the-current-timestamp-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-get-the-current-timestamp-in-javascript/</guid><description>Как получить текущую метку времени в JavaScript</description><pubDate>Sun, 03 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
**Таймстамп (timestamp)** представляет собой способ представления времени в виде числа, обычно количества прошедших миллисекунд с определенного момента времени. В большинстве случаев используется начало эпохи **Unix**, которое приходится на 1 января 1970 года 00:00:00 UTC. Таймстампы широко используются в программировании и компьютерных системах для обработки и хранения временной информации.

В **JavaScript** есть несколько способов получить текущее время и дату в виде метки времени **(timestamp)**, которая обычно представляет собой количество миллисекунд, прошедших с начала эпохи **Unix (1 января 1970 года 00:00:00 UTC)**. 

### Использование `Date` объекта

```javascript
// Создание нового объекта Date с текущим временем
let timestamp = new Date().getTime();

console.log(timestamp);
```

В этом примере `new Date()` создает объект, представляющий текущую дату и время, а метод `getTime()` возвращает количество миллисекунд, прошедших с начала эпохи **Unix**.

### Использование `Date.now()`

```javascript
let timestamp = Date.now();

console.log(timestamp);
```

`Date.now()` - это статический метод объекта Date, который возвращает текущее время в миллисекундах с начала эпохи Unix.

### Использование `+new Date()`

```javascript
let timestamp = +new Date();

console.log(timestamp);
```

Это немного необычный способ, который использует унарный плюс для преобразования объекта `Date` в число, представляющее количество миллисекунд.

&lt;br&gt;

Все эти способы возвращают текущий **timestamp**, который можно использовать в вашем коде для различных операций, таких как установка временных меток, измерения времени выполнения и т.д.</content:encoded></item><item><title>Как добавить элемент в массив по определенному индексу в JavaScript</title><link>https://awilum.ru/articles/how-to-add-item-to-an-array-at-a-specific-index-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-add-item-to-an-array-at-a-specific-index-in-javascript/</guid><description>Как добавить элемент в массив по определенному индексу в JavaScript</description><pubDate>Sat, 02 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
Чтобы добавить элемент в массив по определенному индексу в **JavaScript**, вы можете использовать метод `splice()`. Этот метод позволяет добавить новый элемент в массив и указать индекс, по которому нужно вставить новый элемент. 

Вот пример:

```javascript
// Исходный массив
var myArray = [1, 2, 3, 4, 5];

// Индекс, куда нужно вставить новый элемент
var index = 2;

// Новый элемент, который нужно добавить
var newItem = 10;

// Используем метод splice() для вставки нового элемента по индексу
myArray.splice(index, 0, newItem);

// Выведем измененный массив
console.log(myArray); // [1, 2, 10, 3, 4, 5]
```

В этом примере мы добавляем новый элемент со значением 10 по индексу 2 в массив `myArray` с помощью метода `splice()`. Первый аргумент метода `splice()` - это индекс, по которому будет произведена вставка. Второй аргумент - количество элементов, которые нужно удалить перед вставкой нового элемента. В данном случае мы не удаляем никакие элементы, поэтому второй аргумент равен 0. Третий аргумент - это новый элемент, который мы хотим добавить.</content:encoded></item><item><title>Композиция в Canvas</title><link>https://awilum.ru/articles/canvas-composite/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-composite/</guid><description>Композиция в Canvas</description><pubDate>Fri, 01 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;Композиция включает в себя различные способы наложения одного изображения или элемента рисунка на другой. Существует несколько режимов композиции, которые определяют, как цвета двух объектов смешиваются при их наложении.&lt;/p&gt;

### Использование свойства &lt;code&gt;globalCompositeOperation&lt;/code&gt;

&lt;p&gt;Свойство &lt;code&gt;globalCompositeOperation&lt;/code&gt; контекста рисования позволяет устанавливать режим композиции. Его значения определяют, как цвета рисуемого объекта будут смешиваться с цветами объектов, находящихся под ним.&lt;/p&gt;

```javascript
globalCompositeOperation = &apos;value&apos;;
```

&lt;p&gt;Где &lt;code&gt;value&lt;/code&gt; - одно из допустимых значений для режима композиции.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Примеры значений:&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot; style=&quot;width: 100%;&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;source-over&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Значение по умолчанию.&lt;br&gt;
			Исходное изображение накрывает целевое&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;source-atop&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Исходное изображение накладывается поверх целевого.&lt;br&gt;
			При этом часть исходного изображения, которая выходит&lt;br&gt;
			за границы целевого изображения, не отображается&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;source-in&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Исходное изображение отображается внутри целевого изображения.&lt;br&gt;
			При этом отображается только та часть исходного изображения,&lt;br&gt;
			которая находится в границах целевого изображения.&lt;br&gt;
			Само целевое изображение становится прозрачным&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;source-out&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Исходное изображение отображается вне границ целевого изображения.&lt;br&gt;
			При этом отображается только та часть исходного изображения,&lt;br&gt;
			которая находится за пределами целевого изображения.&lt;br&gt;
			Само целевое изображение становится прозрачным&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;destination-over&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Целевое изображение накрывает исходное&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;destination-atop&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;
			&lt;p&gt;Целевое изображение накладывается поверх исходного.&lt;br&gt;
			При этом часть целевого изображения, которая выходит за границы&lt;br&gt;
			исходного изображения, не отображается&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;destination-in&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Целевое изображение отображается внутри исходного изображения.&lt;br&gt;
			При этом отображается только та часть целевого изображения,&lt;br&gt;
			которая находится в границах исходного изображения.&lt;br&gt;
			Само исходное изображение становится прозрачным&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;destination-out&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Целевое изображение отображается вне границ исходного изображения.&lt;br&gt;
			При этом отображается только та часть целевого изображения,&lt;br&gt;
			которая находится за пределами исходного изображения.&lt;br&gt;
			Само исходное изображение становится прозрачным&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;lighter&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Отображает исходное изображение + целевое изображение&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Отображает исходное изображение.&lt;br&gt;
			Целевое изображение игнорируется&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Исходное изображение комбинируется с целевым используя операцию исключающего ИЛИ&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

### Наложение прямоугольников с режимом &lt;code&gt;source-over&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;source-over&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/oNVadpg?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;source-atop&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;source-atop&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/PoLyegJ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;source-in&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;source-in&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/MWxPGMx?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;source-out&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;source-out&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/ZEPqogZ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;destination-over&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;destination-over&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/LYagrYN?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


### Наложение прямоугольников с режимом &lt;code&gt;destination-atop&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;destination-atop&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/RwdeJNg?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;destination-in&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;destination-in&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/RwdeJPg?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;destination-out&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;destination-out&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/jOJeKPQ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;lighter&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;lighter&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/JjzmZKX?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;copy&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;copy&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/NWJOzrL?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Наложение прямоугольников с режимом &lt;code&gt;xor&lt;/code&gt;

```javascript
// Рисуем первый прямоугольник (синий)
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Применяем режим композиции
ctx.globalCompositeOperation = &apos;xor&apos;;

// Рисуем второй прямоугольник (красный) поверх первого
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(100, 100, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат: &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/XWGxYjJ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Сохранение и восстановление состояния в Canvas</title><link>https://awilum.ru/articles/canvas-save-and-restore/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-save-and-restore/</guid><description>Сохранение и восстановление состояния в Canvas</description><pubDate>Fri, 01 Mar 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;Сохранение и восстановление состояния представляет собой механизм, который позволяет сохранять текущее состояние контекста рисования, включая текущие преобразования, стили и другие настройки, а затем восстанавливать их при необходимости. Этот механизм особенно полезен, когда вы хотите временно изменить настройки рисования, а затем вернуться к предыдущему состоянию без необходимости вручную сохранять и восстанавливать каждый атрибут.&lt;/p&gt;

### Использование методов &lt;code&gt;save()&lt;/code&gt; и &lt;code&gt;restore()&lt;/code&gt;

&lt;p&gt;Существуют два метода для сохранения и восстановления состояния:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Метод &lt;code&gt;save()&lt;/code&gt; сохраняет текущее состояние контекста рисования на стеке состояний.&lt;/li&gt;
	&lt;li&gt;Метод &lt;code&gt;restore()&lt;/code&gt; восстанавливает последнее сохраненное состояние контекста рисования из стека состояний.&lt;/li&gt;
&lt;/ul&gt;

```javascript
// Сохраняем текущее состояние
ctx.save(); 

// Выполняем изменения состояния (например, изменяем преобразования, стили и т. д.)
// ...

// Восстанавливаем предыдущее состояние
ctx.restore();
```

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Рисуем круг до изменений
ctx.fillStyle = &apos;blue&apos;;
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.fill();

// Сохраняем текущее состояние
ctx.save();

// Применяем преобразование
ctx.translate(200, 0);
ctx.rotate(Math.PI / 4);

// Рисуем круг после изменений
ctx.fillStyle = &apos;red&apos;;
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.fill();

// Восстанавливаем предыдущее состояние
ctx.restore();

// Рисуем круг после восстановления
ctx.fillStyle = &apos;green&apos;;
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.fill();
```

&lt;p&gt;В этом примере после вызова &lt;code&gt;save()&lt;/code&gt; текущее состояние контекста сохраняется на стеке состояний. Затем выполняется преобразование (сдвиг и поворот) и рисуется красный круг. После этого с помощью &lt;code&gt;restore()&lt;/code&gt; состояние контекста восстанавливается до предыдущего состояния (до преобразований), и зеленый круг рисуется в исходном положении.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/xxByjVM?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Преобразования в Canvas</title><link>https://awilum.ru/articles/canvas-transformations/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-transformations/</guid><description>Преобразования в Canvas</description><pubDate>Thu, 29 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;&lt;strong&gt;Преобразования &lt;/strong&gt;в &lt;strong&gt;Canvas&lt;/strong&gt; позволяют изменять положение, размер, вращение и искажение элементов, рисуемых на холсте. С помощью преобразований можно создавать сложные и динамичные визуальные эффекты.&lt;/p&gt;

&lt;p&gt;Преобразования включают в себя &lt;strong&gt;сдвиг (translate)&lt;/strong&gt;, &lt;strong&gt;вращение (rotate)&lt;/strong&gt;, &lt;strong&gt;масштабирование (scale)&lt;/strong&gt; и &lt;strong&gt;искажение (transform)&lt;/strong&gt;.&lt;/p&gt;

### Сдвиг (Translate)

&lt;p&gt;&lt;strong&gt;Сдвиг (Translate)&lt;/strong&gt; позволяет перемещать начало координат и элементы на холсте в определенном направлении. Это полезное преобразование, которое позволяет создавать анимации, располагать объекты в нужных местах и создавать сложные композиции из простых фигур.&lt;/p&gt;

#### Использование метода &lt;code&gt;translate()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;translate()&lt;/code&gt;  сдвигает начало координат холста на заданные значения по горизонтали и вертикали. После сдвига все последующие операции рисования будут выполняться относительно нового начала координат.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cинтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
translate(x, y);
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Сдвиг по горизонтали.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Сдвиг по вертикали.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Нарисуем квадрат до сдвига
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Сдвиг начала координат на (100, 50)
ctx.translate(100, 50);

// Нарисуем квадрат после сдвига
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(0, 0, 100, 100);
```

&lt;p&gt;В этом примере после вызова &lt;code&gt;translate(100, 50)&lt;/code&gt; все последующие операции рисования будут сдвигаться на 100 пикселей вправо и 50 пикселей вниз относительно исходного начала координат.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/oNVaoKO?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

#### Совмещение сдвигов

&lt;p&gt;Вы можете вызывать &lt;code&gt;translate()&lt;/code&gt; несколько раз для применения нескольких сдвигов последовательно.&lt;/p&gt;

```javascript
ctx.translate(50, 50); // Сдвиг на (50, 50)
ctx.translate(100, 0); // Сдвиг на (100, 0)
```

#### Обратный сдвиг

&lt;p&gt;Чтобы вернуть начало координат к исходному состоянию, примените обратный сдвиг с отрицательными значениями.&lt;/p&gt;

```javascript
ctx.translate(-100, -50); // Обратный сдвиг на (-100, -50)
```

### &lt;strong&gt;Вращение (Rotate)&lt;/strong&gt;

&lt;p&gt;&lt;strong&gt;Вращение (Rotate)&lt;/strong&gt; поворачивать элементы относительно их начальной позиции. &lt;/p&gt;

#### Использование метода &lt;code&gt;rotate()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;rotate()&lt;/code&gt; контекста рисования вращает координатную систему холста на заданный угол в радианах.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cинтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
rotate(angle);
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Угол вращения в радианах.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Сдвиг начала координат на (100, 0)
ctx.translate(100, 0);

// Нарисуем квадрат до вращения
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Вращение координатной системы на 45 градусов
ctx.rotate(Math.PI / 4);

// Нарисуем квадрат после вращения
ctx.fillStyle = &apos;red&apos;;
ctx.fillRect(50, 50, 100, 100);
```

&lt;p&gt;В этом примере второй квадрат будет нарисован после поворота координатной системы на 45 градусов. Все последующие операции рисования будут выполняться относительно повернутой системы координат.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/eYXPyvL?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Масштабирование (Scale)

&lt;p&gt;&lt;strong&gt;Масштабирование (Scale)&lt;/strong&gt; позволяет изменять размер элементов, нарисованных на холсте. Это преобразование позволяет увеличивать или уменьшать объекты, создавать эффекты перспективы и применять масштабирование в анимациях.&lt;/p&gt;

#### Использование метода &lt;code&gt;scale()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;scale()&lt;/code&gt; контекста рисования масштабирует объекты на холсте по горизонтали и вертикали.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cинтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
scale(scaleX, scaleY);
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;scaleX&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Коэффициент масштабирования по горизонтали.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;scaleY&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Коэффициент масштабирования по вертикали.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Нарисуем круг до масштабирования
ctx.fillStyle = &apos;blue&apos;;
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.fill();

// Масштабирование объекта
ctx.scale(1.5, 1.5);

// Нарисуем круг после масштабирования
ctx.fillStyle = &apos;red&apos;;
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.fill();
```

&lt;p&gt;В этом примере второй круг будет нарисован после масштабирования по горизонтали в 1.5 раза. Масштабирование применяется ко всем последующим операциям рисования, и все они будут масштабироваться с использованием указанных коэффициентов.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/NWJOXva?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Искажение (Transform)

&lt;p&gt;Метод &lt;code&gt;transform()&lt;/code&gt; позволяет производить произвольные преобразования объектов, такие как сдвиг, масштабирование, вращение и искажение. Этот метод применяет матрицу трансформации к текущему состоянию контекста рисования, что позволяет создавать сложные визуальные эффекты.&lt;/p&gt;

#### Использование метода &lt;code&gt;transform()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;transform()&lt;/code&gt; позволяет производить произвольные преобразования путем применения матрицы трансформации.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cинтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
transform(a, b, c, d, e, f)
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt; Элементы матрицы трансформации.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Матрица трансформации имеет следующий вид:&lt;/strong&gt;&lt;/p&gt;

```
| a  c  e |
| b  d  f |
| 0  0  1 |
```

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```
// Нарисуем круг до масштабирования
ctx.fillStyle = &apos;blue&apos;;
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.fill();

// Масштабирование объекта
ctx.scale(1.5, 1.5);

// Нарисуем круг после масштабирования
ctx.fillStyle = &apos;red&apos;;
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2);
ctx.fill();
```

&lt;p&gt;В этом примере &lt;code&gt;transform(1, 0.5, 0.5, 1, 0, 0)&lt;/code&gt; применяет искажение, увеличивая квадрат по горизонтали вдвое и сжимая по вертикали вдвое. Коэффициенты &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; определяют масштабирование и искажение, а &lt;code&gt;e&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; определяют сдвиг.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/wvOYpXr?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Рисование изображений в Canvas</title><link>https://awilum.ru/articles/canvas-draw-images/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-draw-images/</guid><description>Рисование изображений в Canvas</description><pubDate>Wed, 28 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;Рисование изображений на холсте - это процесс отображения растровых изображений, таких как фотографии или другие изображения, Этот процесс обычно включает загрузку изображения и его отображение на холсте с использованием контекста рисования.&lt;/p&gt;

&lt;p&gt;Прежде чем отобразить изображение на холсте, необходимо загрузить его с помощью объекта &lt;code&gt;Image&lt;/code&gt; &lt;strong&gt;JavaScript.&lt;/strong&gt;&lt;/p&gt;

```javascript
const img = new Image();

// Указываем путь к изображению
img.src = &apos;https://ik.imagekit.io/awilum/welcome-to-hawkins.jpg?updatedAt=1702540829891&apos;;
```

&lt;p&gt;После загрузки изображения источник изображения установлен, и мы можем использовать его для отображения на холсте с помощью метода &lt;code&gt;drawImage()&lt;/code&gt; контекста рисования.&lt;/p&gt;

```javascript
// Отображаем изображение на холсте в координатах (x, y)
ctx.drawImage(img, x, y);
```

&lt;p&gt;Метод &lt;code&gt;drawImage()&lt;/code&gt; имеет несколько вариантов использования, позволяющих управлять размерами и масштабированием изображения.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Синтакcис&lt;/strong&gt;:&lt;/p&gt;

```javascript
drawImage(img, dx, dy);
drawImage(img, dx, dy, dWidth, dHeight);
drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;img&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Элемент для отображения в контексте.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;dx&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата по оси Х, обозначающая стартовую точку холста-приёмника,&lt;br&gt;
			в которую будет помещён верхний левый угол исходного &lt;code&gt;image&lt;/code&gt;.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;dy&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата по оси Y, обозначающая стартовую точку холста-приёмника,&lt;br&gt;
			в которую будет помещён верхний левый угол исходного &lt;code&gt;image&lt;/code&gt;.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;dWidth&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Ширина изображения, полученного из исходного &lt;code&gt;image&lt;/code&gt;.&lt;br&gt;
			Эта опция позволяет масштабировать изображение по ширине.&lt;br&gt;
			Если опция не задана, изображение не будет масштабировано.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;dHeight&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Высота изображения, полученного из исходного &lt;code&gt;image&lt;/code&gt;.&lt;br&gt;
			Эта опция позволяет масштабировать изображение по высоте.&lt;br&gt;
			Если опция не задана, изображение не будет масштабировано.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;sx&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата по оси X верхнего левого угла фрагмента,&lt;br&gt;
			который будет вырезан из изображения-источника и помещён в контекст-приёмник.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;sy&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата по оси Y верхнего левого угла фрагмента,&lt;br&gt;
			который будет вырезан из изображения-источника и помещён в контекст-приёмник.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;sWidth&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;
			&lt;p&gt;Ширина фрагмента, который будет вырезан из изображения источника&lt;br&gt;
			и помещён в контекст-приёмник. Если не задана, фрагмент от точки,&lt;br&gt;
			заданной &lt;code&gt;sx&lt;/code&gt; и &lt;code&gt;sy&lt;/code&gt; до правого нижнего угла источника будет целиком&lt;br&gt;
			скопирован в контекст-приёмник.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;sHeight&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Высота фрагмента, который будет вырезан из изображения источника и помещён в контекст-приёмник.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Отображение изображения в его естественном размере:&lt;/strong&gt;&lt;/p&gt;

```javascript
ctx.drawImage(img, 0, 0);
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/MWxPOJJ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Масштабирование изображения до определенной ширины и высоты:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Изображение будет масштабировано до размеров 100x100 пикселей
ctx.drawImage(img, 0, 0, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/zYbmPWR?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Масштабирование изображения до размеров холста:&lt;/strong&gt;&lt;/p&gt;

```javascript
ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/RwdejJz?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Использование метода &lt;code&gt;onLoad()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;onload&lt;/code&gt; объекта &lt;code&gt;Image&lt;/code&gt; является обработчиком события, который вызывается, когда изображение загружено. Это очень важный момент при работе с изображениями в веб-разработке, потому что до момента загрузки изображения вы не можете гарантировать, что оно доступно для отображения или манипуляций.&lt;/p&gt;

&lt;p&gt;Создаем новый объект &lt;code&gt;Image&lt;/code&gt; и устанавливаем его &lt;code&gt;src&lt;/code&gt; на путь к изображению. На этом этапе происходит начало загрузки изображения.&lt;/p&gt;

```javascript
const img = new Image();
img.src = &apos;https://ik.imagekit.io/awilum/welcome-to-hawkins.jpg?updatedAt=1702540829891&apos;;
```

&lt;p&gt;После того как изображение полностью загружено, событие &lt;code&gt;onload&lt;/code&gt; срабатывает, и код внутри обработчика выполняется.&lt;/p&gt;

```javascript
img.onload = function() {
    // В этом блоке кода можно выполнять действия с изображением,
    // которые должны произойти после его загрузки.

   ctx.drawImage(img, 0, 0);
   console.log(&apos;Изображение загружено!&apos;);
};
```

### Зачем это нужно?

&lt;ul&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Гарантия доступности изображения.&lt;/strong&gt;&lt;br&gt;
	Используя &lt;code&gt;onload&lt;/code&gt;, вы убеждаетесь, что изображение загружено и доступно для использования, прежде чем пытаться отобразить его или выполнить другие операции с ним.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Избегание ошибок.&lt;/strong&gt;&lt;br&gt;
	Без обработчика &lt;code&gt;onload&lt;/code&gt; существует риск попытаться отобразить изображение, которое еще не загружено, что может привести к ошибкам.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Выполнение действий после загрузки.&lt;/strong&gt;&lt;br&gt;
	Обработчик &lt;code&gt;onload&lt;/code&gt; позволяет вам выполнить определенные действия только после того, как изображение загружено, например, установить его как фон холста или выполнить манипуляции с изображением.&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Рисование кривых Безье в Canvas</title><link>https://awilum.ru/articles/canvas-draw-curve/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-draw-curve/</guid><description>Рисование кривых Безье в Canvas</description><pubDate>Tue, 27 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;&lt;strong&gt;Кривые Безье &lt;/strong&gt;— это математические кривые, которые широко используются в компьютерной графике для создания плавных и красивых кривых. Они были впервые разработаны французским инженером &lt;strong&gt;Пьером Безье&lt;/strong&gt; в 1960-х годах для описания автомобильных кузовов в компании Renault. Кривые Безье могут быть различных порядков, включая линейные (порядка 1), квадратичные (порядка 2), кубические (порядка 3) и т. д.&lt;/p&gt;

&lt;p&gt;Для рисования кривых Безье в Canvas доступны следующие методы: &lt;code&gt;quadraticCurveTo()&lt;/code&gt; и &lt;code&gt;bezierCurveTo()&lt;/code&gt;&lt;/p&gt;

### Рисование с помощью метода &lt;code&gt;quadraticCurveTo()&lt;/code&gt;

&lt;p&gt;Этот метод добавляет кривую Безье к текущему пути, определяемую начальной точкой пути (текущей позицией), одной контрольной точкой &lt;code&gt;(cp1x, cp1y)&lt;/code&gt; и конечной точкой &lt;code&gt;(x, y)&lt;/code&gt;. Это квадратичная кривая Безье.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Синтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
quadraticCurveTo(cpx, cpy, x, y)
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;cpx&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата оси X контрольной точки.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;cpy&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата оси Y контрольной точки.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата X новой позиции курсора.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата Y новой позиции курсора.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
ctx.beginPath();
ctx.moveTo(50, 50); // Начальная точка

// Квадратичная кривая Безье с одной контрольной точкой
ctx.quadraticCurveTo(100, 150, 150, 50);

ctx.stroke(); // Рисуем контур пути
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/ExMeygL?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Рисование с помощью метода &lt;code&gt;bezierCurveTo()&lt;/code&gt;

&lt;p&gt;Этот метод добавляет кривую Безье к текущему пути, определяемую начальной точкой пути (текущей позицией), двумя контрольными точками &lt;code&gt;(cp1x, cp1y)&lt;/code&gt; и &lt;code&gt;(cp2x, cp2y)&lt;/code&gt; и конечной точкой &lt;code&gt;(x, y)&lt;/code&gt;. Это кубическая кривая Безье.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Синтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;cp1x, cp1y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата первой контрольной точки по оси X и Y.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;cp2x, cp2y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата второй контрольной точки по оси X и Y.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата X конечной позиции курсора.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата Y конечной позиции курсора.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
ctx.beginPath();
ctx.moveTo(50, 50); // Начальная точка
ctx.bezierCurveTo(100, 100, 150, 150, 200, 50); // Кубическая кривая Безье
ctx.stroke(); // Рисуем контур пути
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/GReXjRj?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Рисование дуги в Canvas</title><link>https://awilum.ru/articles/canvas-draw-arc/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-draw-arc/</guid><description>Рисование дуги в Canvas</description><pubDate>Mon, 26 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;Дуга создается с использованием методов&amp;nbsp;&lt;code&gt;arc()&lt;/code&gt; и&amp;nbsp;&lt;code&gt;arcTo()&lt;/code&gt;&lt;/p&gt;

### Рисование с помощью метода&amp;nbsp;&lt;code&gt;arc()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;arc()&lt;/code&gt; используется для создания дуги или круга на холсте. Он задает дугу с центром в точке &lt;code&gt;(x, y)&lt;/code&gt;, указанным радиусом, начальным и конечным углом в радианах и направлением (по или против часовой стрелки).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата X центра дуги.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата Y центра дуги.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;radius&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Радиус дуги.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;startAngle&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Начальный угол в радианах, с которого начинается дуга (0 - находится на правой горизонтальной оси).&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;endAngle&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Конечный угол в радианах, на котором заканчивается дуга.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;anticlockwise&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Направление дуги (против часовой стрелки - &lt;code&gt;true&lt;/code&gt;, по часовой - &lt;code&gt;false&lt;/code&gt;).&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример (рисование круга):&lt;/strong&gt;&lt;/p&gt;

```javascript
// Начинаем новый путь
ctx.beginPath();

// Рисуем дугу (круг) с центром в точке (100, 100) и радиусом 50
ctx.arc(100, 100, 50, 0, Math.PI * 2);

// Закрываем путь (для круга это не обязательно)
// ctx.closePath();

// Рисуем контур пути
ctx.strokeStyle = &apos;blue&apos;; // Цвет контура
ctx.lineWidth = 2; // Толщина линии
ctx.stroke();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/xxBaObj?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


### Рисование с помощью метода&amp;nbsp;&lt;code&gt;arcTo()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;arcTo()&lt;/code&gt;&amp;nbsp;используется для добавления дуги к текущему пути, соединяющей текущую точку с точкой &lt;code&gt;(x2, y2)&lt;/code&gt; с радиусом &lt;code&gt;radius&lt;/code&gt;, и предыдущей линией с точки &lt;code&gt;(x1, y1)&lt;/code&gt;. Это позволяет создавать более плавные углы между линиями, чем просто использование метода &lt;code&gt;lineTo()&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x1, y1&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координаты начальной точки предыдущей линии.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x2, y2&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координаты конечной точки текущей линии.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;radius&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Радиус дуги.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Начинаем новый путь
ctx.beginPath();

// Перемещаем &quot;курсор&quot; в точку (20, 20)
ctx.moveTo(20, 20);

// Рисуем прямую линию до точки (100, 20)
ctx.lineTo(100, 20);

// Добавляем дугу, соединяющую текущую линию и предыдущую, с радиусом 30
ctx.arcTo(150, 20, 150, 70, 30);

// Рисуем прямую линию до точки (150, 120)
ctx.lineTo(150, 120);

// Закрываем путь
ctx.closePath();

// Рисуем контур пути
ctx.strokeStyle = &apos;blue&apos;; // Цвет контура
ctx.lineWidth = 2; // Толщина линии
ctx.stroke();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/abMaZOY?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Рисование линии в Canvas</title><link>https://awilum.ru/articles/canvas-draw-line/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-draw-line/</guid><description>Рисование линии в Canvas</description><pubDate>Sun, 25 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;&lt;strong&gt;Рисование прямой линии&lt;/strong&gt; &amp;mdash;&amp;nbsp;одно из самых простых и распространенных действий при использовании &lt;strong&gt;Canvas&lt;/strong&gt; для создания графики с помощью &lt;strong&gt;JavaScript&lt;/strong&gt;. Для рисования прямой линии используется метод &lt;code&gt;lineTo(x, y)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Метод &lt;code&gt;lineTo(x, y)&lt;/code&gt; используется для добавления линии от текущей позиции (позиции &amp;quot;курсора&amp;quot;) до указанной точки (x, y) на холсте. При этом сама линия не рисуется, пока не будет вызван метод для рисования контура или заливки.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата X позиции конца линии.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата Y&amp;nbsp;позиции конца линии.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Начинаем новый путь
ctx.beginPath();

// Перемещаем &quot;курсор&quot; в точку (50, 50)
ctx.moveTo(50, 50);

// Добавляем линию от текущей позиции до точки (150, 150)
ctx.lineTo(150, 150);

// Закрываем путь
ctx.closePath();

// Рисуем контур пути
ctx.strokeStyle = &apos;blue&apos;; // Цвет контура
ctx.lineWidth = 2; // Толщина линии
ctx.stroke();
```

&lt;p&gt;В этом примере мы начинаем новый путь с помощью &lt;code&gt;beginPath()&lt;/code&gt;, затем перемещаем &amp;quot;курсор&amp;quot; в точку (50, 50) с помощью &lt;code&gt;moveTo(50, 50)&lt;/code&gt;, добавляем линию до точки (150, 150) с помощью &lt;code&gt;lineTo(150, 150)&lt;/code&gt;, а затем рисуем контур пути с помощью &lt;code&gt;stroke()&lt;/code&gt;. Линия будет нарисована в указанных координатах с заданным цветом и толщиной линии.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/zYbJGVP?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


### Рисование линии на основе пользовательского ввода

&lt;p&gt;Допустим, у пользователя есть возможность рисовать линию, задавая точки с помощью мыши. В этом примере мы можем использовать события мыши для отслеживания пользовательского ввода и рисования линии.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;nbsp;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
let isDrawing = false;
let lastX = 0;
let lastY = 0;

function draw(e) {
  if (!isDrawing) return;
  ctx.beginPath();
  ctx.moveTo(lastX, lastY);
  ctx.lineTo(e.offsetX, e.offsetY);
  ctx.stroke();
  [lastX, lastY] = [e.offsetX, e.offsetY];
}

canvas.addEventListener(&apos;mousedown&apos;, (e) =&amp;gt; {
  isDrawing = true;
  [lastX, lastY] = [e.offsetX, e.offsetY];
});

canvas.addEventListener(&apos;mousemove&apos;, draw);
canvas.addEventListener(&apos;mouseup&apos;, () =&amp;gt; isDrawing = false);
canvas.addEventListener(&apos;mouseout&apos;, () =&amp;gt; isDrawing = false);
```

&lt;p&gt;Этот код позволяет пользователю рисовать линию, перетаскивая мышь по холсту.&lt;/p&gt;

&lt;p&gt;Давайте разберем, как это работает:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;p&gt;Переменные &lt;code&gt;isDrawing&lt;/code&gt;, &lt;code&gt;lastX&lt;/code&gt; и &lt;code&gt;lastY&lt;/code&gt; используются для отслеживания состояния рисования (включено или выключено) и последней позиции мыши.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;Функция &lt;code&gt;draw(e)&lt;/code&gt; вызывается каждый раз при перемещении мыши по холсту &lt;code&gt;mousemove&lt;/code&gt;. Она проверяет, включено ли рисование &lt;code&gt;isDrawing&lt;/code&gt;. Если рисование выключено, функция завершает свое выполнение. Если рисование включено, функция начинает новый путь &lt;code&gt;beginPath()&lt;/code&gt;, перемещает &amp;quot;курсор&amp;quot; в предыдущие координаты &lt;code&gt;moveTo(lastX, lastY)&lt;/code&gt;&amp;nbsp;и рисует линию от предыдущих координат до текущих координат мыши &lt;code&gt;lineTo(e.offsetX, e.offsetY)&lt;/code&gt;. После этого линия обводится c помощью&amp;nbsp;&lt;code&gt;stroke()&lt;/code&gt;. Последние координаты мыши обновляются на текущие координаты &lt;code&gt;lastX = e.offsetX&lt;/code&gt;, &lt;code&gt;lastY = e.offsetY&lt;/code&gt;.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;Событие &lt;code&gt;mousedown&lt;/code&gt; срабатывает при нажатии кнопки мыши на холсте. При этом флаг &lt;code&gt;isDrawing&lt;/code&gt; устанавливается в &lt;code&gt;true&lt;/code&gt;, и переменные &lt;code&gt;lastX&lt;/code&gt; и &lt;code&gt;lastY&lt;/code&gt; устанавливаются в текущие координаты мыши &lt;code&gt;e.offsetX&lt;/code&gt;, &lt;code&gt;e.offsetY&lt;/code&gt;.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;Событие &lt;code&gt;mouseup&lt;/code&gt; срабатывает, когда кнопка мыши отпускается. Это приводит к установке флага &lt;code&gt;isDrawing&lt;/code&gt; в &lt;code&gt;false&lt;/code&gt;, что прекращает рисование на холсте.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;Событие &lt;code&gt;mouseout&lt;/code&gt; срабатывает, когда курсор мыши покидает область холста. Аналогично событию &lt;code&gt;mouseup&lt;/code&gt;, это также приводит к установке флага &lt;code&gt;isDrawing&lt;/code&gt; в &lt;code&gt;false&lt;/code&gt;, чтобы предотвратить рисование при перемещении мыши вне холста.&lt;/p&gt;
	&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/poYOEJK?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;Для очистки холста, нажмите на кнопку &amp;quot;Rerun&amp;quot; или перезагрузите страницу.&lt;/p&gt;

### Рисование кардиоиды

&lt;p&gt;&lt;strong&gt;Кардиоида&lt;/strong&gt; &amp;mdash; плоская линия, которая описывается фиксированной точкой окружности, катящейся по неподвижной окружности с таким же радиусом. Получила своё название из-за схожести своих очертаний со стилизованным изображением сердца.&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;250&quot; name=&quot;&quot; src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/83/EpicycloidK1.gif&quot; width=&quot;250&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
ctx.beginPath();
ctx.strokeStyle = &apos;green&apos;;
ctx.lineWidth = 2;

for (let t = 0; t &amp;lt;= Math.PI * 2; t += 0.01) {
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
    ctx.lineTo(x + canvas.width / 2, -y + canvas.height / 2);
}

ctx.stroke();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/ExMdbrp?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Рисование параболы

&lt;p&gt;&lt;strong&gt;Парабола&lt;/strong&gt; &amp;mdash; плоская кривая, один из типов конических сечений.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
ctx.beginPath();
ctx.strokeStyle = &apos;blue&apos;;
ctx.lineWidth = 2;

for (let x = -canvas.width / 2; x &amp;lt;= canvas.width / 2; x += 0.1) {
    const y = x * x / 100;
    ctx.lineTo(x + canvas.width / 2, -y + canvas.height / 2);
}

ctx.stroke();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/GReYObJ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


### Рисование синусоиды

&lt;p&gt;&lt;strong&gt;Синусоида&lt;/strong&gt; &amp;mdash; плоская кривая, задаваемая в прямоугольных координатах уравнением График уравнения вида также зачастую называется синусоидой. Данный график получается из синусоидального сдвигом на в отрицательном направлении оси абсцисс.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
ctx.beginPath();
ctx.strokeStyle = &apos;red&apos;;
ctx.lineWidth = 2;

for (let x = -canvas.width / 2; x &amp;lt;= canvas.width / 2; x += 0.1) {
    const y = Math.sin(x / 50) * 50; 
    ctx.lineTo(x + canvas.width / 2, -y + canvas.height / 2);
}

ctx.stroke();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/YzgJEom?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Перемещение курсора в Canvas</title><link>https://awilum.ru/articles/canvas-move-cursor/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-move-cursor/</guid><description>Перемещение курсора в Canvas</description><pubDate>Sun, 25 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;Перемещение курсора полезно, когда вы хотите начать новый путь или перейти к другой части холста без создания видимой линии. Метод &lt;code&gt;moveTo()&lt;/code&gt; используется для управления позицией, откуда начинается рисование. Он позволяет перемещать &quot;курсор&quot; по холсту без рисования линии.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Синтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
moveTo(x, y);
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата X новой позиции курсора.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align: center;&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата Y новой позиции курсора.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Начинаем новый путь
ctx.beginPath();

// Перемещаем &quot;курсор&quot; в точку (50, 50)
ctx.moveTo(50, 50);

// Добавляем линию от текущей позиции до указанной точки (100, 100)
ctx.lineTo(100, 100);

// Закрываем путь
ctx.closePath();

// Рисуем контур пути
ctx.strokeStyle = &apos;blue&apos;; // Цвет контура
ctx.lineWidth = 2; // Толщина линии
ctx.stroke();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/MWxqwLb?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Рисование контуров в Canvas</title><link>https://awilum.ru/articles/canvas-draw-path/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-draw-path/</guid><description>Рисование контуров в Canvas</description><pubDate>Sat, 24 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;&lt;strong&gt;Рисование контуров&lt;/strong&gt;, также известное как &lt;strong&gt;работа с путями (path)&lt;/strong&gt;, представляет собой способ создания сложных форм и фигур на холсте. Работа с путями позволяет создавать кривые, ломаные линии, а также комбинировать различные фигуры в одном элементе. В основе работы с путями лежит использование методов для создания пути, а затем применение методов для его рисования и/или заливки.&lt;/p&gt;

&lt;p&gt;Создание фигур с использованием контуров включает в себя несколько важных шагов:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Начинается с создания контура.&lt;/li&gt;
	&lt;li&gt;Затем, с помощью команд рисования, контур рисуется.&lt;/li&gt;
	&lt;li&gt;После этого контур закрывается.&lt;/li&gt;
	&lt;li&gt;Созданный контур можно обвести или заполнить для его отображения.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ниже приведены некоторые методы, которые могут быть использованы на каждом из описанных шагов.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Создание пути:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;code&gt;beginPath()&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Метод начинает новый путь или очищает текущий путь.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
			&lt;p&gt;&lt;code&gt;...()&lt;/code&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;Методы для установки различных контуров объекта.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;code&gt;closePath()&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Закрывает текущий путь, соединяя последнюю точку с первой.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Рисование пути:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;code&gt;stroke()&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Рисует контур пути.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Заливает внутренность пути.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример (рисование треугольника):&lt;/strong&gt;&lt;/p&gt;

```javascript
// Начинаем новый путь
ctx.beginPath();

// Перемещаем &quot;курсор&quot; в точку (50, 50)
ctx.moveTo(50, 50);

// Добавляем линии до двух других точек, чтобы создать треугольник
ctx.lineTo(100, 100);
ctx.lineTo(150, 50);

// Закрываем путь, соединяя последнюю точку с первой
ctx.closePath();

// Рисуем контур пути
ctx.strokeStyle = &apos;blue&apos;; // Цвет контура
ctx.lineWidth = 2; // Толщина линии
ctx.stroke();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/BabOymY?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Рисование прямоугольника в Canvas</title><link>https://awilum.ru/articles/canvas-draw-rect/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-draw-rect/</guid><description>Рисование прямоугольника в Canvas</description><pubDate>Fri, 23 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;Рисование прямоугольников на элементе &lt;strong&gt;Canvas&lt;/strong&gt; &amp;mdash;&amp;nbsp;одно из самых базовых и часто используемых действий при создании графики на веб-странице с помощью &lt;strong&gt;JavaScript&lt;/strong&gt;. Прямоугольники можно использовать для создания различных элементов интерфейса, фонов, рамок и многого другого. Давайте рассмотрим подробно, как рисовать прямоугольники на &lt;strong&gt;Canvas&lt;/strong&gt;.&lt;/p&gt;

### Использование метода &lt;code&gt;fillRect()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;fillRect()&lt;/code&gt; используется для создания прямоугольника, который заполняется цветом и находится в заданных координатах (x, y), имея размеры, определяемые параметрами &lt;code&gt;width&lt;/code&gt; и &lt;code&gt;height&lt;/code&gt;. Стиль заполнения прямоугольника задается с помощью свойства &lt;code&gt;fillStyle&lt;/code&gt;.&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Синтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
fillRect(x, y, width, height)
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата начальной точки прямоугольника по оси x.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;&amp;nbsp;Координата начальной точки прямоугольника по оси y.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Ширина прямоугольника.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;height&lt;/code&gt;&amp;nbsp;&lt;/td&gt;
			&lt;td&gt;Высота прямоугольника.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Задаем цвет заливки
ctx.fillStyle = &apos;red&apos;;

// Рисуем прямоугольник с координатами (x, y) и размерами (width, height)
ctx.fillRect(50, 50, 100, 100);
```

&lt;p&gt;В этом примере мы рисуем красный прямоугольник с верхним левым углом в точке (50, 50) и размерами 100 пикселей в ширину и 100 пикселей в высоту.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/WNmgNPZ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Использование метода &lt;code&gt;strokeRect()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;strokeRect()&lt;/code&gt; используется для рисования на холсте с начальной точкой в заданных координатах (x, y), а также с заданной шириной (w) и высотой (h), используя текущий стиль линий.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Синтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
strokeRect(x, y, width, height)
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x&lt;/code&gt;&amp;nbsp;&lt;/td&gt;
			&lt;td&gt;Координата начальной точки прямоугольника по оси x.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата начальной точки прямоугольника по оси y.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Ширина прямоугольника.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Высота прямоугольника.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Задаем цвет обводки и толщину линии
ctx.strokeStyle = &apos;blue&apos;;
ctx.lineWidth = 2;

// Рисуем обведенный прямоугольник с координатами (x, y) и размерами (width, height)
ctx.strokeRect(200, 50, 100, 100);
```

&lt;p&gt;В этом примере мы рисуем синий прямоугольник с верхним левым углом в точке (200, 50) и размерами 100 пикселей в ширину и 100 пикселей в высоту.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/wvOEvbe?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

### Настройка цвета и стиля

&lt;p&gt;Вы можете настраивать цвет и стиль заливки и обводки прямоугольника, используя свойства &lt;code&gt;fillStyle&lt;/code&gt;, &lt;code&gt;strokeStyle&lt;/code&gt; и &lt;code&gt;lineWidth&lt;/code&gt; контекста рисования.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Задаем цвет заливки и обводки
ctx.fillStyle = &apos;green&apos;;
ctx.strokeStyle = &apos;purple&apos;;

// Задаем толщину линии
ctx.lineWidth = 4;

// Рисуем прямоугольник с заливкой и обводкой
ctx.fillRect(50, 150, 100, 50);
ctx.strokeRect(200, 150, 100, 50);
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/rNRZaVP?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;В &lt;strong&gt;Canvas&lt;/strong&gt; цвет можно задавать в различных форматах.&lt;/p&gt;

&lt;p&gt;Ниже перечислены некоторые из наиболее распространенных форматов:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Именованные цвета&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вы можете использовать предопределенные имена цветов, такие как &amp;quot;red&amp;quot; (красный), &amp;quot;blue&amp;quot; (синий), &amp;quot;green&amp;quot; (зеленый) и т. д.&lt;/p&gt;

```javascript
ctx.fillStyle = &apos;red&apos;;
ctx.strokeStyle = &apos;blue&apos;;
```

&lt;p&gt;&lt;strong&gt;HEX-коды&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Цвет можно задать в формате HEX-кода, который представляет собой шестнадцатеричное значение RGB (красный, зеленый, синий).&lt;/p&gt;

```javascript
ctx.fillStyle = &apos;#ff0000&apos;; // Красный
ctx.strokeStyle = &apos;#0000ff&apos;; // Синий
```

&lt;p&gt;&lt;strong&gt;RGB-значения&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вы можете указать цвет, используя значения красного (R), зеленого (G) и синего (B) компонентов в диапазоне от 0 до 255.&lt;/p&gt;

```javascript
ctx.fillStyle = &apos;rgb(255, 0, 0)&apos;; // Красный
ctx.strokeStyle = &apos;rgb(0, 0, 255)&apos;; // Синий
```

&lt;p&gt;&lt;strong&gt;RGBA-значения&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Также можно задать цвет с альфа-каналом (прозрачность), добавив четвертый параметр, который представляет собой значение альфа в диапазоне от 0 до 1.&lt;/p&gt;

```javascript
ctx.fillStyle = &apos;rgba(255, 0, 0, 0.5)&apos;; // Полупрозрачный красный
ctx.strokeStyle = &apos;rgba(0, 0, 255, 0.7)&apos;; // Полупрозрачный синий
```

&lt;p&gt;Выбор формата для задания цвета зависит от ваших предпочтений и требований проекта.&lt;/p&gt;

&lt;p&gt;Вот некоторые соображения, которые могут помочь вам принять решение:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;Простота использования&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;Гибкость и точность&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Именованные цвета (например, &amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;) - самые простые в использовании, поскольку они легко запоминаются и читаются. Однако они ограничены предопределенным списком цветов.&lt;/td&gt;
			&lt;td&gt;Форматы HEX-кодов, RGB и RGBA обеспечивают большую гибкость и точность при выборе цвета. Вы можете точно настроить каждый канал (красный, зеленый, синий) и альфа-канал (прозрачность), чтобы получить нужный цвет.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

### Использование метода&amp;nbsp;&lt;code&gt;clearRect()&lt;/code&gt;

&lt;p&gt;Метод &lt;code&gt;clearRect()&lt;/code&gt; используется для очистки прямоугольной области на холсте, удаляя любые нарисованные ранее объекты или цвет заливки.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Синтаксис:&lt;/strong&gt;&lt;/p&gt;

```javascript
clearRect(x, y, width, height)
```

&lt;p&gt;&lt;strong&gt;Параметры:&lt;/strong&gt;&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x&lt;/code&gt;&amp;nbsp;&lt;/td&gt;
			&lt;td&gt;Координата начальной точки прямоугольника по оси x.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Координата начальной точки прямоугольника по оси y.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Ширина прямоугольника.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;height&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Высота прямоугольника.&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Рисуем что-то на холсте
ctx.fillStyle = &apos;blue&apos;;
ctx.fillRect(50, 50, 100, 100);

// Очищаем прямоугольную область
ctx.clearRect(60, 60, 80, 80);
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/VwRGYPj?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;


&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Координатная система в Canvas</title><link>https://awilum.ru/articles/canvas-coordinates/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-coordinates/</guid><description>Координатная система в Canvas</description><pubDate>Thu, 22 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;&lt;strong&gt;Координатная система&lt;/strong&gt; &amp;mdash; это математический инструмент, используемый для определения положения точек в пространстве или на плоскости. Она состоит из двух осей (или трех, в трехмерном пространстве), пересекающихся в точке, которая называется началом координат. Каждая из осей имеет определенное направление, и на них отложены числа, которые обозначают координаты точек.&lt;/p&gt;

&lt;p&gt;Существует несколько различных типов координатных систем, но наиболее распространенные из них - это декартова координатная система и полярная координатная система.&lt;/p&gt;

### Декартова координатная система

&lt;center&gt;&lt;img alt=&quot;&quot; height=&quot;400&quot; name=&quot;&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/coordinates-cartesian.png?updatedAt=1709815703088&quot; width=&quot;400&quot; /&gt;&lt;/center&gt;

&lt;p&gt;В декартовой координатной системе используются две перпендикулярные оси, обычно обозначаемые как x и y.&lt;/p&gt;

&lt;p&gt;Начало координат располагается в точке пересечения этих осей.&lt;/p&gt;

&lt;p&gt;Каждая точка в этой системе определяется уникальной парой чисел (x, y), где x - это расстояние по горизонтальной оси (ось x), а y - это расстояние по вертикальной оси (ось y).&lt;/p&gt;

&lt;p&gt;Расстояние от начала координат до точки на плоскости может быть определено с использованием теоремы Пифагора или формулы расстояния между двумя точками.&lt;/p&gt;

### Полярная координатная система

&lt;center&gt;&lt;img alt=&quot;&quot; height=&quot;500&quot; name=&quot;Polar_graph_paper.svg.png&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/coordinates-polar.png?updatedAt=1709815703107&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;p&gt;В полярной координатной системе точки задаются расстоянием (обычно обозначается как r) от начала координат и углом (обычно обозначается как &amp;theta;), который эта точка образует с положительным направлением оси x.&lt;/p&gt;

&lt;p&gt;Начало координат также располагается в центре системы.&lt;/p&gt;

&lt;p&gt;Таким образом, каждая точка в полярной координатной системе определяется уникальной парой (r, &amp;theta;).&lt;/p&gt;

&lt;p&gt;В трехмерном пространстве добавляется третья ось (обычно обозначаемая как z) для создания трехмерной декартовой координатной системы. В этом случае каждая точка определяется тройкой координат (x, y, z).&lt;/p&gt;

&lt;p&gt;В компьютерной графике также широко используются координатные системы, особенно для определения положения объектов на экране монитора или в трехмерном пространстве в виртуальном мире. Однако, в компьютерной графике используются свои концепции и терминология.&lt;/p&gt;

### Двумерная координатная система

&lt;center&gt;&lt;img alt=&quot;&quot; height=&quot;363&quot; name=&quot;&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/coordinates-2d.png?updatedAt=1709815703191&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;


&lt;p&gt;В двумерной компьютерной графике обычно используется декартова координатная система с началом координат в левом верхнем углу экрана.&lt;/p&gt;

&lt;p&gt;Ось x направлена вправо, а ось y направлена вниз.&lt;/p&gt;

&lt;p&gt;Пиксели на экране идентифицируются их координатами (x, y), где x - это расстояние от левого края экрана, а y - это расстояние от верхнего края экрана.&lt;/p&gt;

&lt;p&gt;Обычно для измерения расстояний используются пиксели, а начало координат (0, 0) находится в левом верхнем углу экрана.&lt;/p&gt;

### Трехмерная координатная система

&lt;center&gt;&lt;img alt=&quot;&quot; height=&quot;487&quot; name=&quot;&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/coordinates-3d.png?updatedAt=1709815703184&quot; width=&quot;487&quot; /&gt;&lt;/center&gt;

&lt;p&gt;В трехмерной компьютерной графике используется трехмерная декартова координатная система, включающая ось z, которая направлена вглубь экрана.&lt;/p&gt;

&lt;p&gt;Каждая точка в трехмерном пространстве определяется тройкой координат (x, y, z).&lt;/p&gt;

&lt;p&gt;В этой системе начало координат обычно находится в центре экрана, хотя в различных графических движках и приложениях это может быть изменено.&lt;/p&gt;

### Координатная система в Canvas

&lt;p&gt;Координатная система в &lt;strong&gt;Canvas&lt;/strong&gt; работает следующим образом: начало координат находится в верхнем левом углу, ось X направлена вправо, а ось Y - вниз.&lt;/p&gt;

&lt;center&gt;&lt;img alt=&quot;&quot; height=&quot;410&quot; name=&quot;&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/coordinates-canvas.jpg?updatedAt=1709815703350&quot; width=&quot;500&quot; /&gt;&lt;/center&gt;

&lt;p&gt;Давайте рассмотрим более подробно, как работает координатная система на &lt;strong&gt;Canvas&lt;/strong&gt;.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Начало координат.&lt;/strong&gt;&lt;br /&gt;
	Верхний левый угол Canvas является началом координат.&lt;br /&gt;
	Координата (0,0) находится в этой точке.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Ось X.&lt;/strong&gt;&lt;br /&gt;
	Ось X направлена вправо от начала координат.&lt;br /&gt;
	Положительные значения X увеличиваются вправо, а отрицательные - влево.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Ось Y.&lt;/strong&gt;&lt;br /&gt;
	Ось Y направлена вниз от начала координат.&lt;br /&gt;
	Положительные значения Y увеличиваются вниз, а отрицательные - вверх.&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;&lt;strong&gt;Единицы измерения.&lt;/strong&gt;&lt;br /&gt;
	По умолчанию, единицы измерения на Canvas - это пиксели.&lt;br /&gt;
	Каждый пиксель представляет одну единицу по осям X и Y.&lt;/p&gt;
	&lt;/li&gt;
&lt;/ol&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Начинаем работать с Canvas</title><link>https://awilum.ru/articles/canvas-getting-started/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-getting-started/</guid><description>Начинаем работать с Canvas</description><pubDate>Wed, 21 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;&lt;strong&gt;Canvas&lt;/strong&gt;&amp;nbsp;&amp;mdash; это элемент &lt;strong&gt;HTML5&lt;/strong&gt;, который позволяет создавать и рисовать графику на веб-странице с использованием &lt;strong&gt;JavaScript&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Давайте рассмотрим основные шаги по работе с &lt;strong&gt;Canvas&lt;/strong&gt;.&lt;/p&gt;

### Шаг 1: Создание Canvas элемента

&lt;p&gt;Первым шагом является создание элемента &lt;strong&gt;Canvas&lt;/strong&gt; на веб-странице. Это можно сделать с помощью тега &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; в HTML.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;300&quot;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Этот тег создаст &lt;strong&gt;Canvas&lt;/strong&gt; с уникальным идентификатором &lt;code&gt;myCanvas&lt;/code&gt; и размерами &lt;code&gt;500&lt;/code&gt; пикселей в ширину и &lt;code&gt;300&lt;/code&gt; пикселей в высоту.&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

### Шаг 2: Получение контекста рисования

&lt;p&gt;Для работы с &lt;strong&gt;Canvas&lt;/strong&gt; нам нужно получить контекст рисования.&lt;/p&gt;

&lt;p&gt;В &lt;strong&gt;JavaScript&lt;/strong&gt; мы можем сделать это с помощью метода &lt;code&gt;getContext()&lt;/code&gt;.&lt;/p&gt;

```javascript
const canvas = document.getElementById(&apos;myCanvas&apos;);
const ctx = canvas.getContext(&apos;2d&apos;);
```

&lt;p&gt;Мы получаем элемент &lt;strong&gt;Canvas&lt;/strong&gt; по его идентификатору, а затем получаем контекст рисования &lt;strong&gt;2D&lt;/strong&gt;, который используется для рисования на &lt;strong&gt;Canvas&lt;/strong&gt;.&amp;nbsp;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;В &lt;strong&gt;JavaScript&lt;/strong&gt;, объект &lt;code&gt;document&lt;/code&gt; представляет текущий &lt;strong&gt;HTML-документ &lt;/strong&gt;в браузере. Этот объект предоставляет интерфейс для взаимодействия с содержимым и структурой веб-страницы. Он является частью &lt;strong&gt;DOM&lt;/strong&gt; &lt;strong&gt;(Document Object Model) API&lt;/strong&gt;, который представляет документ в виде иерархического дерева узлов, таких как элементы, атрибуты и текстовые узлы.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Метод &lt;code&gt;getContext()&lt;/code&gt; используется для получения контекста рисования для элемента &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; в &lt;strong&gt;HTML&lt;/strong&gt;. Этот метод может принимать различные аргументы в зависимости от типа контекста, который вы хотите получить.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;code&gt;2d&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Этот контекст используется для рисования &lt;strong&gt;2D графики&lt;/strong&gt;.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;code&gt;webgl&lt;/code&gt;&amp;nbsp;или &lt;code&gt;experimental-webgl&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Этот контекст используется для создания &lt;strong&gt;3D графики&lt;/strong&gt; с помощью &lt;strong&gt;WebGL&lt;/strong&gt;.&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;code&gt;bitmaprenderer&lt;/code&gt;&lt;/td&gt;
			&lt;td&gt;Этот контекст используется для рендеринга векторной графики.&amp;nbsp;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;В курсе будет рассмотрен &lt;code&gt;2d&lt;/code&gt;&amp;nbsp;контекст используемый&amp;nbsp;для рисования &lt;strong&gt;2D графики&lt;/strong&gt; на элементе &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

### Шаг 3: Рисование простых фигур

&lt;p&gt;Теперь, когда у нас есть контекст рисования, мы можем рисовать на &lt;strong&gt;Canvas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ниже приведены примеры рисования нескольких простых фигур.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Рисование прямоугольника:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Устанавливаем цвет заливки
ctx.fillStyle = &apos;red&apos;;

// Рисуем прямоугольник
ctx.fillRect(50, 50, 100, 100);
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/abMjKzp?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Рисование окружности:&lt;/strong&gt;&lt;/p&gt;

```javascript
// Начинаем новый путь
ctx.beginPath();

// Рисуем окружность
ctx.arc(200, 150, 50, 0, Math.PI * 2);

// Устанавливаем цвет заливки
ctx.fillStyle = &apos;blue&apos;;

// Заливаем окружность
ctx.fill();
```

&lt;p&gt;&lt;strong&gt;Результат:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe allowfullscreen=&quot;true&quot; height=&quot;500&quot; scrolling=&quot;no&quot; src=&quot;https://codepen.io/Awilum/embed/dyrjKPZ?default-tab=result&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Это базовые шаги по использованию &lt;strong&gt;Canvas&lt;/strong&gt; в &lt;strong&gt;JavaScript&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Вы можете использовать эти примеры для создания простых графических элементов на вашей веб-странице.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Canvas&lt;/strong&gt; предоставляет широкий набор методов для рисования, и вы можете экспериментировать с ними, чтобы создать различные визуальные эффекты и другую графику.&lt;/p&gt;


&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title>Краткая история Canvas</title><link>https://awilum.ru/articles/canvas-short-history/</link><guid isPermaLink="true">https://awilum.ru/articles/canvas-short-history/</guid><description>Краткая история Canvas</description><pubDate>Tue, 20 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
&lt;p&gt;&lt;strong&gt;Canvas&lt;/strong&gt; &amp;mdash; это элемент &lt;strong&gt;HTML5&lt;/strong&gt;, который представляет собой прямоугольную область на странице, которую можно настраивать и рисовать на ней с помощью &lt;strong&gt;JavaScript&lt;/strong&gt;.&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Первые признаки тогда еще проприетарного элемента &lt;strong&gt;Canvas&lt;/strong&gt;&amp;nbsp;были внесены в древо исходного кода &lt;strong&gt;WebKit&lt;/strong&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;&lt;strong&gt;Ричардом Уильямсоном&lt;/strong&gt; 25 мая 2004 года. Идея &lt;strong&gt;Apple&lt;/strong&gt; заключалась в том, чтобы предоставить доступ к системе рисования &lt;strong&gt;Quartz&lt;/strong&gt; операционной системы &lt;strong&gt;Mac OS X&lt;/strong&gt; для &lt;strong&gt;JavaScript&lt;/strong&gt; и &lt;strong&gt;HTML&lt;/strong&gt;, чтобы упростить написание графических виджетов для &lt;strong&gt;Apple Dashboard&lt;/strong&gt;. Следовательно, поскольку оба продукта используют один и тот же движок рендеринга, элемент стал доступен также в браузере &lt;strong&gt;Safari&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Несколько лет ранее, в конце октября 2001 года, Джо Хьюитт открыл issue &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=102285&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;#102285&lt;/a&gt; в системе отслеживания ошибок &lt;strong&gt;Mozilla&lt;/strong&gt;. Предлагая тот же самый элемент и мотивацию, его предложение заключалось в реализации пользовательского элемента управления рисованием для &lt;strong&gt;XML User Interface Language Mozilla&lt;/strong&gt;. &lt;strong&gt;Брендан Айк&lt;/strong&gt;, создатель языка &lt;strong&gt;JavaScript&lt;/strong&gt;, отверг идею как нечто для фанатов рендеринга.&lt;/p&gt;

&lt;p&gt;Первого апреля 2005 года &lt;strong&gt;Владимир Вукичевич &lt;/strong&gt;из &lt;strong&gt;Mozilla&lt;/strong&gt; загрузил патч с базовыми функциями &lt;strong&gt;Canvas&lt;/strong&gt;, который открыл путь для дальнейшей работы в &lt;strong&gt;Firefox&lt;/strong&gt;. Хотя эта первая реализация работала только в &lt;strong&gt;Linux&lt;/strong&gt; из-за разных форматов цвета в &lt;strong&gt;Windows&lt;/strong&gt; и &lt;strong&gt;Mac OS X&lt;/strong&gt;, выход их проекта &amp;quot;Deer Park&amp;quot; в конце ноября, известного как Firefox 1.5, представил кросс-платформенную реализацию &lt;strong&gt;Canvas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Opera ввел элемент &lt;strong&gt;Canvas&lt;/strong&gt; в середине 2006 года с выпуском &lt;strong&gt;Opera 9&lt;/strong&gt;. Это означало, что все основные браузеры, за исключением &lt;strong&gt;Internet Explorer&lt;/strong&gt;, реализовали элемент на уровне ядра. Однако это не означало, что элемент &lt;strong&gt;Canvas&lt;/strong&gt;&amp;nbsp;был непригоден для использования, так как проекты Google ExCanvas и Mozilla IECanvas обеспечили ограниченную поддержку элемента в браузере Microsoft.&lt;/p&gt;

&lt;p&gt;Путь к правильной стандартизации был далеко не гладким. Это началось с отсутствия должного предложения со стороны &lt;strong&gt;Apple&lt;/strong&gt;, что привело к тому, что первая спецификация была основана на работах по обратной инженерии Иэна Хиксона, редактора спецификации &lt;strong&gt;HTML5&lt;/strong&gt;. В 2005 году Джаянт Сай выдвинул первую идею относительно рисования текста на холсте, которая позже была оформлена в приличное предложение Стефаном Хаустайном.&lt;/p&gt;

&lt;p&gt;Тем не менее, не все прошло гладко. После того как Mozilla Firefox и Opera реализовали элемент &lt;strong&gt;Canvas&lt;/strong&gt;, Хелен Плотка Уоркман, старший юрист &lt;strong&gt;Apple&lt;/strong&gt; по патентам, отправила сообщение в &lt;strong&gt;WHATWG&lt;/strong&gt; и Иэну Хиксону, заявив, что Apple считает себя владельцем интеллектуальной собственности по элементу холста и рассмотрит возможность предоставления этих прав интеллектуальной собственности только в случае принятия чернового стандарта Веб-приложений в качестве формализованного стандарта с &lt;strong&gt;W3C&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;В феврале 2008 года, был опубликован первый черновик спецификации &lt;strong&gt;HTML5&lt;/strong&gt; как рабочий черновик &lt;strong&gt;W3C&lt;/strong&gt;. 18 июня того же года &lt;strong&gt;Apple&lt;/strong&gt; раскрыла патент &lt;a href=&quot;https://www.freepatentsonline.com/y2006/0005114.html&quot; rel=&quot;noopener noreferrer nofollow&quot;&gt;11/144384&lt;/a&gt; для использования спецификации &lt;strong&gt;HTML5&lt;/strong&gt;. Тот же патент был раскрыт в еще шести юрисдикциях, что позволило &lt;strong&gt;WHATWG&lt;/strong&gt; продолжать включать новый элемент &lt;strong&gt;Canvas&lt;/strong&gt;.&lt;/p&gt;

&lt;div&gt;
&lt;h3 class=&quot;text-3xl mt-4 mb-4&quot;&gt;Cтатьи про Canvas&lt;/h4&gt;
&lt;div class=&quot;pt-10 pb-10 border-black border-t-2 text-center grid grid-cols-1 lg:grid-cols-2 gap-4&quot;&gt;
&lt;a href=&quot;/articles/canvas-short-history/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Краткая история Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-getting-started/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white px-4 py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Начинаем работать с Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-coordinates/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Координатная система в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-rect/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование прямоугольника в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-path/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование контуров в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-move-cursor/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Перемещение курсора в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-line/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование линии в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-arc/&quot; class=&quot;bg-white text-black border-2 border-black rounded  hover:bg-black hover:text-white py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование дуги в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-curve/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование кривых Безье в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-draw-images/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Рисование изображений в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-transformations/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Преобразования в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-save-and-restore/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Сохранение и восстановление состояния в Canvas&lt;/a&gt;
&lt;a href=&quot;/articles/canvas-composite/&quot; class=&quot;bg-white text-black border-2 border-black rounded hover:bg-black hover:text-white  py-2 mr-2 flex items-center justify-center no-underline&quot;&gt;Композиция в Canvas&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;

</content:encoded></item><item><title>Преимущества использования let и const по сравнению с var в JavaScript</title><link>https://awilum.ru/articles/advantages-of-using-let-and-const-over-var-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/advantages-of-using-let-and-const-over-var-in-javascript/</guid><description>Преимущества использования let и const по сравнению с var в JavaScript</description><pubDate>Mon, 19 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
До появления **ECMAScript 6(ES6)**, ключевое слово `var` использовалось для объявления переменных в **JavaScript**. Однако, с появлением **ES6**, были введены два новых способа объявления переменных: `let` и `const`. С появлением этих новых возможностей, использование `var` стало менее желательным по нескольким причинам.


### Область видимости.

Переменные, объявленные с помощью `var`, имеют функциональную область видимости если она объявлена внутри функции или глобальная если объявлена глобально. Это означает, что переменная видна внутри функции или скрипта, в которой она объявлена, но &lt;u&gt;не ограничивается блоками кода&lt;/u&gt;, такими как условные операторы (`if`, `for`, `while`) или блоки `{}`. Это может приводить к неожиданному поведению, особенно при работе с циклами.

### Поднятие.

Переменные, объявленные с помощью `var`, поднимаются (hoist) вверх внутри функции или глобальной области видимости. Это означает, что переменные могут быть использованы до того, как они фактически были объявлены. Это также может приводить к неожиданным результатам и ошибкам в коде.&lt;br /&gt;
&lt;br /&gt;
Пример c `var`:

```javascript
console.log(x); // undefined

var x = 10;

console.log(x); // 10	
```

Пример c `let`:

```javascript
console.log(x); // ReferenceError: Cannot access &apos;x&apos; before initialization

let x = 10;

console.log(x);
```

### Замыкания.

Из-за функциональной области видимости переменных с `var`, замыкания могут вести себя не так, как ожидается. Замыкания &amp;ndash; это функции, которые запоминают значения переменных из окружающей их области видимости. В случае с `var`, замыкания могут быть запутанными и приводить к утечкам памяти.

### Отсутствие блочной область видимости.

`let` и `const`, в отличие от `var`, имеют блочную область видимости, ограниченную фигурными скобками `{}`. Это позволяет более точно контролировать область видимости переменных, что часто считается более предсказуемым и безопасным.

&lt;br&gt;&lt;br&gt;

Поэтому, если вы пишете **код на современном JavaScript**, рекомендуется использовать `let` или `const` вместо `var`. `let` используется для переменных, значения которых могут изменяться, в то время как `const` используется для объявления переменных, значения которых не должны изменяться после инициализации. Эти изменения в синтаксисе помогают сделать код более понятным и уменьшить возможные ошибки, связанные с областью видимости и поднятием.
</content:encoded></item><item><title>Как проверить пустой объект в JavaScript?</title><link>https://awilum.ru/articles/how-to-test-for-an-empty-object-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-test-for-an-empty-object-in-javascript/</guid><description>Как проверить пустой объект в JavaScript?</description><pubDate>Mon, 19 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
В JavaScript существует несколько способов проверки на то, является ли объект пустым. 

Пустой объект - это объект, у которого нет свойств, не содержит ни одного ключа. 

### Проверка на количество свойств

Это, пожалуй, самый распространённый способ проверки на пустоту объекта. 

Можно использовать `Object.keys()` для получения массива всех ключей объекта, а затем проверить длину этого массива.

```javascript
function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}
```

Пример использования:

```javascript
const obj = {};
console.log(isEmpty(obj)); // true

const objWithProps = { a: 1, b: 2 };
console.log(isEmpty(objWithProps)); // false
```

### Проверка с помощью цикла `for...in`

Можно использовать цикл for...in для перебора всех свойств объекта. Если объект пуст, то цикл не выполнит ни одной итерации.

```javascript
function isEmpty(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
```

Пример использования аналогичен предыдущему.

Выбор метода зависит от ваших предпочтений и контекста. Обычно метод с использованием `Object.keys()` предпочтительнее из-за его краткости и читаемости.</content:encoded></item><item><title>Как исправить арифметику с десятичными числами в JavaScript?</title><link>https://awilum.ru/articles/how-to-fix-decimals-arithmetic-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-fix-decimals-arithmetic-in-javascript/</guid><description>Статья рассматривает понятие &quot;ошибка выжившего&quot; в контексте информационных технологий (IT). Описывается, как это искажение может влиять на принятие решений, основанных только на успешных кейсах, и предоставляются примеры из сферы IT. В частности, подчеркивается важность анализа не только успешных, но и неудачных опытов для более обоснованных стратегических решений в IT.</description><pubDate>Wed, 14 Feb 2024 00:00:00 GMT</pubDate><content:encoded>
При попытке сложить два десятичных числа в JavaScript вы можете столкнуться с неожиданным поведением. Например, результат 0.1 + 0.1 будет ожидаемым - 0.2.

&lt;center&gt;
&lt;img width=&quot;600&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/Screenshot%202024-02-14%20at%2010.18.55.png?updatedAt=1707880870066&quot; /&gt;
&lt;/center&gt;

Однако иногда вы получите неожиданный результат. Например, при выполнении операции 0.1 + 0.2.

Результат не будет равен 0.3, как ожидается, а будет 0.30000000000000004.

&lt;center&gt;
&lt;img width=&quot;600&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/Screenshot%202024-02-14%20at%2010.19.52.png?updatedAt=1707880870036&quot; /&gt;
&lt;/center&gt;

Аналогично, при вычислении выражения 1.4 - 1 результатом будет 0.3999999999999999.

&lt;center&gt;
&lt;img width=&quot;600&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/Screenshot%202024-02-14%20at%2010.20.05.png?updatedAt=1707880870036&quot; /&gt;
&lt;/center&gt;

Это явление не уникально для JavaScript, оно возникает в любом языке программирования.

Причина этого заключается в том, что компьютеры хранят данные в двоичной системе, а не в десятичной. Некоторые десятичные числа не могут быть точно представлены в двоичной форме, что приводит к потере точности при выполнении вычислений.

Для обхода этой проблемы вы можете использовать библиотеки, такие как [decimal.js](https://mikemcl.github.io/decimal.js/), [bignumber.js](https://mikemcl.github.io/bignumber.js/) или [big.js](https://mikemcl.github.io/big.js/).

Вы также можете использовать следующий трюк.

Вы обрезаете десятичные знаки после 2 позиций, и умножить число на 100, чтобы удалить десятичную часть.

Затем вы делите на 100 после выполнения суммирования:
```javascript
(0.1.toFixed(2) * 100 + 0.2.toFixed(2) * 100) / 100
```

&lt;center&gt;
&lt;img width=&quot;600&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/Screenshot%202024-02-14%20at%2010.29.12.png?updatedAt=1707881384539&quot; /&gt;
&lt;/center&gt;

Более практичный вариант:
```javascript
const sum = (a, b, positions) =&gt; {
  const factor = Math.pow(10, positions)
  return (a.toFixed(positions) * factor + b.toFixed(positions) * factor) / factor
}

sum(0.1, 0.2, 4);
```


&lt;center&gt;
&lt;img width=&quot;600&quot; src=&quot;https://ik.imagekit.io/awilum/awilum-ru/Screenshot%202024-02-14%20at%2010.32.27.png?updatedAt=1707881572692&quot; /&gt;
&lt;/center&gt;</content:encoded></item><item><title>Принципы проектирования программного обеспечения</title><link>https://awilum.ru/articles/software-design-principles/</link><guid isPermaLink="true">https://awilum.ru/articles/software-design-principles/</guid><description>Принципы проектирования программного обеспечения</description><pubDate>Tue, 16 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Проектирование программного обеспечения (Software Design) является одним из ключевых аспектов успешной разработки программных продуктов. Хорошо спроектированное программное обеспечение не только обеспечивает функциональность и эффективность, но также является легким в поддержке, гибким и расширяемым. Для достижения этих целей существуют ряд фундаментальных принципов, которые помогают разработчикам создавать качественное ПО.

Важным аспектом проектирования программного обеспечения является анализ требований. Разработчики должны полностью понимать потребности пользователей и функциональные требования, чтобы создать систему, которая будет удовлетворять их ожидания. В процессе анализа требований осуществляется сбор и документирование информации, определение основных функций системы, идентификация ограничений и взаимодействий с другими системами.

При проектировании программного обеспечения важно учитывать принципы модульности, высокой связности и слабой зависимости между компонентами системы. Это позволяет создать гибкую и расширяемую архитектуру, где каждый модуль выполняет конкретную функцию и может быть легко изменен или заменен без влияния на другие компоненты. Такой подход способствует повторному использованию кода и облегчает сопровождение и развитие программного обеспечения в долгосрочной перспективе.

Кроме того, при проектировании программного обеспечения важно уделять внимание аспектам безопасности, производительности, масштабируемости и использованию ресурсов. Разработчики должны обеспечить надежность системы, защиту от возможных уязвимостей и эффективное использование аппаратных и программных ресурсов. Это позволит создать качественное программное обеспечение, которое будет надежно работать в различных сценариях использования и справится с растущей нагрузкой.
Хорошо спроектированное программное обеспечение обеспечивает не только нужную функциональность, но и простоту использования, гибкость, эффективность и масштабируемость в будущем.

При проектировании программного обеспечения разработчики используют различные методики и подходы, которые помогают создавать качественное и эффективное программное обеспечение. Вот несколько известных принципов проектирования программного обеспечения, которые широко используются в индустрии: **YAGNI**, **KISS**, **DRY**, **SOLID**, **BDUF**, **Occam&apos;s Razor**.

Проектирование программного обеспечения (ПО) играет ключевую роль в успешной разработке программных продуктов и вот почему:

1. **Обеспечение функциональности и эффективности.**  
Хорошо спроектированное ПО должно полностью соответствовать требованиям пользователей и функциональным требованиям. Только тогда оно сможет предоставить необходимую функциональность, обеспечивая эффективное выполнение задач.

2. **Легкость в поддержке.**  
Грамотное проектирование упрощает процессы поддержки и обновлений. Когда архитектура программы понятна и модульна, внесение изменений или устранение ошибок становится более простым и меньше вероятность воздействия на другие части системы.

3. **Гибкость и расширяемость.**  
Принципы модульности, связности и слабой зависимости способствуют созданию гибкой и расширяемой архитектуры. Это важно для того, чтобы ПО могло легко адаптироваться к изменениям требований пользователей и условий рынка.

4. **Анализ требований.**  
Внимательный анализ требований позволяет разработчикам понять потребности пользователей. Тщательная документация требований является основой для успешного проектирования, предотвращая недопонимания и ошибки в последующих этапах разработки.

5. **Безопасность.**  
При проектировании необходимо уделять особое внимание аспектам безопасности. Защита от уязвимостей и правильное управление доступом к данным являются неотъемлемой частью качественного программного обеспечения.

6. **Производительность и масштабируемость.**  
Проектирование должно учитывать производительность и способность системы масштабироваться. Это важно для обеспечения эффективной работы приложения в условиях растущей нагрузки и изменяющихся условий эксплуатации.

7. **Эффективное использование ресурсов.**  
Разработчики должны оптимально использовать аппаратные и программные ресурсы, чтобы обеспечить эффективность работы приложения и избежать излишних нагрузок на систему.

8. **Простота использования.**  
Хорошее проектирование не только удовлетворяет технические требования, но и обеспечивает удобство использования для конечных пользователей. Простой и интуитивный интерфейс важен для успешной реализации программного продукта.

9. **Долгосрочная перспектива.**  
Качественное программное обеспечение, спроектированное с учетом всех вышеописанных аспектов, обеспечивает долгосрочную устойчивость и удовлетворение потребностей пользователей даже при изменяющихся условиях.

### **YAGNI**

**YAGNI** – это акроним от фразы &quot;You Ain&apos;t Gonna Need It&quot; (Тебе это не понадобится).  

Это принцип разработки программного обеспечения, который призывает избегать создания функциональности, которая в данный момент не является необходимой.

Принцип **YAGNI** подразумевает, что разработчики не должны тратить время на реализацию функциональности, которая не требуется в текущем контексте или не подтверждена конкретными требованиями или сценариями использования. Вместо этого следует сосредоточиться на создании функциональности, которая действительно необходима и требуется в настоящий момент.

Преимущества применения принципа **YAGNI** включают:

1. **Простота.**  
Избегание излишней сложности и функциональности позволяет создавать более простые и понятные системы.

2. **Гибкость.**  
Отсутствие ненужной функциональности делает систему более гибкой и легко поддерживаемой. Удаление ненужного кода или функциональности требует меньше усилий.

3. **Эффективность.**  
Фокусировка на необходимой функциональности позволяет сосредоточить усилия на ее качественной реализации и тестировании.

4. **Ускорение разработки.**  
Избегание создания неиспользуемой функциональности позволяет сократить время разработки и ускорить доставку продукта.

Принцип **YAGNI** не означает, что разработчики не должны быть гибкими и адаптивными к изменяющимся требованиям. В случае, если новая функциональность становится необходимой в будущем, ее можно добавить на основе актуальных требований и контекста.

Принцип **YAGNI** является одним из принципов Agile-разработки и способствует созданию более эффективного и гибкого программного обеспечения.

Гибкие методики разработки (agile software development, agile-разработка) — обобщающий термин для целого ряда подходов и практик, основанных на ценностях Манифеста гибкой разработки программного обеспечения и 12 принципах, лежащих в его основе.

Основные идеи:

1. люди и взаимодействие важнее процессов и инструментов;
2. работающий продукт важнее исчерпывающей документации;
3. сотрудничество с заказчиком важнее согласования условий контракта;
4. готовность к изменениям важнее следования первоначальному плану.

Основополагающие принципы Agile Manifesto:

1. наивысшим приоритетом признается удовлетворение заказчика за счёт ранней и бесперебойной поставки ценного программного обеспечения;
2. изменение требований приветствуется даже в конце разработки (это может повысить конкурентоспособность полученного продукта);
3. частая поставка работающего программного обеспечения (каждые пару недель или пару месяцев с предпочтением меньшего периода);
4. общение представителей бизнеса с разработчиками должно быть ежедневным на протяжении всего проекта;
5. проекты следует строить вокруг заинтересованных людей, которых следует обеспечить нужными условиями работы, поддержкой и доверием;
6. самый эффективный метод обмена информацией в команде — личная встреча;
7. работающее программное обеспечение — лучший измеритель прогресса;
спонсоры, разработчики и пользователи должны иметь возможность поддерживать постоянный темп на - неопределённый срок;
8. постоянное внимание к техническому совершенству и хорошему проектированию увеличивают гибкость;
9. простота, как искусство не делать лишней работы, очень важна;
10. лучшие требования, архитектура и проектные решения получаются у самоорганизующихся команд;
11. команда регулярно обдумывает способы повышения своей эффективности и соответственно корректирует рабочий процесс.

В разработке игр применение принципа **YAGNI** позволяет более эффективно использовать доступные ресурсы и сосредоточиться на ключевых функциях, оптимизируя процесс разработки.

Представим, что вы разрабатываете простую игру-платформер, где игрок управляет персонажем, прыгает по платформам и собирает предметы. Согласно принципу **YAGNI**, вы должны фокусироваться на реализации базового функционала игры, который обеспечивает основной игровой процесс.

В начале разработки игры вы создаете основной механизм управления персонажем, анимацию прыжка и коллизии для платформ и предметов. Однако, вам приходит в голову идея добавить дополнительные функции, такие как система бонусов или множество уровней с разными темами оформления.

Принцип **YAGNI** подразумевает, что в данном случае лучше начать с реализации базового игрового процесса. После завершения основной функциональности вы сможете оценить, насколько дополнительные функции действительно необходимы и принести значимую пользу игровому опыту.

Возможно, вы обнаружите, что ваша игра уже достаточно интересна и увлекательна без сложных бонусных уровней или вариаций множества тем оформления.

Принцип **YAGNI** помогает избежать излишней сложности и избыточной работы при разработке игры. Он позволяет сосредоточиться на создании базового функционала, а затем расширять его по мере необходимости, основываясь на фактических потребностях игры и обратной связи игроков. Данный принцип применяется в разработке игр и других приложений.

### **KISS**

**KISS** – это акроним от &quot;Keep It Simple, Stupid&quot; (Делайте это просто, глупцы).

Этот принцип заключается в том, что решения должны быть простыми и понятными, а не излишне сложными.

Принцип **KISS** подразумевает, что простота является ключом к лучшей понятности, поддерживаемости и надежности кода.

Применение принципа **KISS** включает следующие аспекты:

- Избегайте излишней сложности и ухищрений в дизайне и реализации.
- Предпочтительно выбирайте простые решения перед сложными, если они достаточно эффективны.
- Используйте понятные и описательные имена переменных, функций и классов.
- Разделяйте сложные задачи на более простые и понятные подзадачи.
- Следуйте принципу минимальной информации (Principle of Least Astonishment), чтобы поведение системы было интуитивным для пользователей.
- Принцип **KISS** помогает облегчить разработку, поддержку и понимание кода, а также снизить вероятность ошибок, связанных со сложностью.
- В разработке игр принцип **KISS** подразумевает создание простых и понятных решений, избегая излишней сложности.
- Принцип **KISS** помогает разработчикам создавать игры, которые легко понять, использовать и поддерживать.

Рассмотрим простой пример применения принципа **KISS** в разработке игры:

Предположим, вы разрабатываете игру-головоломку, в которой игроку нужно перемещать объекты по игровому полю, чтобы достичь определенной цели.

В соответствии с принципом **KISS**, вы стремитесь к простоте и ясности в разработке игры.

1. **Простой интерфейс.**  
Вы создаете простой и интуитивно понятный пользовательский интерфейс. Например, используете минималистичные кнопки для управления объектами, ясные инструкции и понятные символы или иконки для обозначения функций.

2. **Ограниченное количество правил.**  
Вы определяете небольшое количество простых правил, которые регулируют перемещение объектов и достижение цели. Это помогает избежать излишней сложности и позволяет игрокам быстро понять, как играть.

3. **Понятные уровни.**  
Ваша игра предлагает последовательность уровней с увеличивающейся сложностью. Однако вы следуете принципу **KISS**, чтобы уровни оставались понятными и логичными. Вы вводите новые элементы геймплея постепенно, объясняете их простыми способами и даете игрокам возможность освоиться с каждым новым элементом перед переходом к более сложным заданиям.

4. **Минимальные детали.**  
Вы уделяете внимание основным игровым механикам и аспектам, не перегружая игру дополнительными и сложными функциями, которые несут мало ценности для геймплея. Вы выбираете самые важные и интересные элементы и сосредотачиваетесь на их разработке и улучшении.

Принцип **KISS** помогает создать игру, которая будет привлекательной и доступной для широкой аудитории. Простота и ясность в дизайне и геймплее способствуют легкому пониманию игры и увлекательному игровому опыту. Данный принцип применяется в разработке игр и других приложений.

### **DRY**

**DRY** – это акроним от &quot;Don&apos;t Repeat Yourself&quot; (не повторяйся).

Этот принцип гласит, что каждая часть знания или функциональности в системе должна иметь единственный источник и не должна дублироваться. Повторяющийся код или дублирующиеся данные могут привести к увеличению сложности, ухудшению поддерживаемости и возможности возникновения ошибок. При соблюдении принципа **DRY** следует вынести общую логику, функции или данные в переиспользуемые компоненты, чтобы избежать дублирования и обеспечить единственный источник правды (Single Source Of Truth — SSOT).

В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте. SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.

Принцип **DRY** применяется не только к коду, но и к другим аспектам разработки, таким как базы данных, конфигурационные файлы, документация и т.д. Цель состоит в том, чтобы уменьшить сложность, повысить эффективность разработки и обеспечить легкость поддержки кода и системы в целом.

В разработке игр принцип **DRY** подразумевает избегание повторения кода или логики, путем создания повторно используемых компонентов или функций. Это позволяет уменьшить дублирование кода, упростить его поддержку и обновление, а также повысить эффективность разработки.

Рассмотрим пример применения принципа **DRY** в разработке игры:

Представим, что вы разрабатываете ролевую игру, в которой игрок может собирать различные предметы и использовать их в битвах.

В соответствии с принципом **DRY**, вы стремитесь к повторному использованию кода и избегаете дублирования функциональности.

1. **Создание базового класса предметов.**  
Вы создаете базовый класс, который определяет общие свойства и функциональность для всех предметов в игре, таких как имя, описание, стоимость и действия. Это позволяет избежать повторения кода для каждого отдельного предмета и упрощает добавление новых предметов в игру.

2. **Использование модулей и компонентов.**  
Вы разделяете функциональность игры на модули и компоненты, которые можно повторно использовать. Например, вы создаете компонент для управления инвентарем игрока, который может использоваться в разных частях игры. Это позволяет избежать дублирования кода для каждой ситуации, где требуется управление инвентарем.

3. **Извлечение общей логики.**  
Если в игре есть повторяющиеся действия или алгоритмы, вы извлекаете их в отдельные функции или классы. Например, если у вас есть несколько боевых сцен, где игрок может использовать специальные атаки, вы создаете отдельную функцию для выполнения специальной атаки и повторно используете ее во всех сценах.

4. **Управление данными централизованно.**  
Вы используете централизованное хранилище данных для игры, где информация о предметах, персонажах и других элементах хранится в одном месте. Это позволяет избежать дублирования данных и облегчает их изменение и обновление.

Принцип **DRY** помогает уменьшить сложность кода, улучшить его читаемость и облегчить его поддержку. Повторное использование кода и логики способствует более эффективной разработке игры. При изменении функциональности или добавлении новых элементов в игру, вам потребуется внести изменения только в одном месте, что упрощает обновление и снижает риск ошибок.

Например, если вы вносите изменения в базовый класс предметов, они автоматически отразятся на всех предметах в игре, которые используют этот класс. Это экономит время и силы разработчиков, позволяя им сосредоточиться на новой функциональности и улучшении игрового опыта.

Принцип **DRY** также способствует более легкому тестированию игры, поскольку функциональность, реализованная однажды в отдельной компоненте или функции, может быть протестирована и отлажена единожды, а затем многократно использована в различных ситуациях.

В итоге, применение принципа **DRY** в разработке игр приводит к улучшению эффективности, упрощению кода, повышению его читаемости, облегчению поддержки и расширяемости игры. А также позволяет разработчикам сосредоточиться на создании новых функций и улучшении геймплея, вместо траты времени на повторение одного и того же кода и функциональности в разных частях игры. Данный принцип применяется в разработке игр и других приложений.

### **SOLID**

**SOLID** – это аббревиатура, состоящая из первых букв пяти принципов объектно-ориентированного программирования, сформулированных Робертом Мартином (также известным как &quot;дядя Боб&quot;)

1. **Принцип единственной ответственности (Single Responsibility Principle - SRP)**  
Каждый класс должен быть ответственен только за одну четко определенную функцию или задачу.

2. **Принцип открытости/закрытости (Open/Closed Principle - OCP)**  
Программные сущности должны быть открытыми для расширения, но закрытыми для изменения.
Изменения должны происходить путем добавления нового кода, а не изменения существующего.

3. **Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP)**  
Объекты должны быть заменяемыми своими подтипами без изменения корректности программы. Если класс A является подтипом класса B, то объекты типа B могут быть безопасно использованы вместо объектов типа A.

4. **Принцип разделения интерфейса (Interface Segregation Principle - ISP)**  
Клиенты не должны зависеть от интерфейсов, которые они не используют.
Принцип разделения интерфейсов говорит о том, что слишком &quot;толстые&quot; интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют.

5. **Принцип инверсии зависимостей (Dependency Inversion Principle - DIP)**  
Зависимости должны строиться на абстракциях, а не на конкретных реализациях. Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба уровня должны зависеть от абстракций.

Соблюдение принципов **SOLID** помогает создавать гибкие, расширяемые и поддерживаемые программные системы.

В разработке игр принципы **SOLID** помогают создавать гибкую, модульную и легко расширяемую архитектуру игры.

Рассмотрим применение принципа **SOLID** на примере разработки игры:

1. **Принцип единственной ответственности (Single Responsibility Principle - SRP)**  
Каждый класс или модуль в игре должен иметь только одну ответственность.     

    Например, у вас может быть класс, отвечающий за управление врагами в игре. Он должен заниматься только логикой врагов, а не смешивать эту ответственность с другими задачами, такими как отображение графики или управление пользовательским интерфейсом.

2. **Принцип открытости/закрытости (Open/Closed Principle - OCP)**  
Код должен быть открытым для расширения, но закрытым для модификации. 

    Вы должны разрабатывать компоненты, которые можно легко расширять новыми функциями или возможностями, без необходимости изменения существующего кода. Например, создание базового класса для различных типов оружия, который можно легко расширять для добавления новых видов оружия без изменения базовой логики.

3. **Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP)**  
Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения корректности исходной программы.  

    Каждый подкласс должен соответствовать интерфейсу родительского класса и сохранять его контракты и предусловия. Например, если у вас есть базовый класс для игровых персонажей, каждый конкретный персонаж должен быть заменяемым без нарушения логики и правил игры.

4. **Принцип разделения интерфейса (Interface Segregation Principle - ISP)**  
Клиенты не должны зависеть от интерфейсов, которые они не используют. 

    Каждый класс или модуль должен иметь свой собственный интерфейс, содержащий только необходимые для него методы. Например, если у вас есть класс управления звуком в игре, он должен иметь только методы, связанные с управлением звуком, и не должен содержать методы, не относящиеся к этой функциональности.

5. **Принцип инверсии зависимостей (Dependency Inversion Principle - DIP)**  
Зависимости должны строиться на абстракциях, а не на конкретных реализациях. 

    Вы должны программировать на уровне интерфейсов или абстрактных классов, а не на уровне конкретных классов. Например, если у вас есть модуль управления входными событиями, он должен зависеть от абстрактного интерфейса для обработки событий, а не от конкретной реализации этого интерфейса.

Принципы **SOLID** помогают создавать гибкую, модульную и легко расширяемую архитектуру игры. Они способствуют уменьшению зависимостей между компонентами, повышению переиспользуемости кода, улучшению тестирования и облегчению сопровождения проекта. Данный принцип применяется в разработке игр и других приложений.

### **BDUF**

**BDUF** – это акроним от фразы &quot;Big Design Up Front&quot; (Глобальное проектирование прежде всего), является подходом к разработке программного обеспечения, основным принципом которого является создание полного и детального дизайна системы еще до начала разработки.

**BDUF** предполагает, что все требования и аспекты системы должны быть полностью определены и специфицированы заранее, а затем на основе этих спецификаций разрабатывается общая архитектура и дизайн системы. Такой подход предполагает, что с точностью можно предугадать все необходимые изменения и детали системы еще до ее создания.

&lt;blockquote&gt;
Зачастую продумывание решений избавляло нас от проблем при разработке… Внесение изменений в спецификации занимало час или два. Если бы мы вносили эти изменения в код, на это уходили бы недели. Я даже не могу выразить, насколько сильно я верю в важность проектирования перед реализацией, хотя адепты экстремального программирования предали эту практику анафеме. Я экономил время и делал свои продукты лучше, используя **BDUF**, и я горжусь этим фактом, чтобы там ни говорили фанатики экстремального программирования. Они просто ошибаются, иначе сказать не могу.&lt;br&gt;&lt;br&gt;
— &lt;b&gt;Джоел Спольски&lt;/b&gt;&lt;br&gt;
&lt;/blockquote&gt;

Принцип **BDUF** имеет свои недостатки. Во-первых, создание полного дизайна заранее требует больших временных и ресурсных затрат, что может привести к задержкам в разработке. Во-вторых, **BDUF** не учитывает возможность изменения требований или обстоятельств в процессе разработки, что может привести к необходимости внесения значительных изменений в уже разработанный дизайн.

В современных методологиях разработки ПО, таких как гибкие методы разработки (Agile Software Development), принцип **BDUF** обычно не рекомендуется. Вместо этого, акцент ставится на итеративном и инкрементальном подходе, где дизайн и разработка происходят параллельно, а требования и детали системы уточняются и корректируются на протяжении всего процесса разработки.

В конечном счете, выбор между принципом **BDUF** и другими подходами зависит от специфики проекта, его размера, сложности и требований. В некоторых случаях, особенно при разработке крупных и сложных систем, предварительное планирование и детальный дизайн могут быть полезными. Однако в большинстве ситуаций рекомендуется более гибкий и итеративный подход, который позволяет более гибко реагировать на изменения и улучшать систему на протяжении всего процесса разработки.

&lt;blockquote&gt;
&lt;b&gt;Джоел Спольски&lt;/b&gt; — программист и писатель. Известен прежде всего как автор блога «Джоэл о программном обеспечении», в котором он обсуждает вопросы программирования, прежде всего — под Windows. В 1991—1994 годах он занимал должность менеджера по продуктам в команде Microsoft Excel.
В разработке игр, принцип **BDUF**, предполагает что все аспекты игры, включая дизайн, архитектуру, функциональность и технологии, планируются и проектируются вначале процесса разработки, до того, как начинается фактическая реализация.
&lt;/blockquote&gt;

Принцип **BDUF** был распространен в традиционной водопадной (Waterfall) модели разработки, где все этапы проекта проходят последовательно и требуют предварительного планирования и документирования. Однако, в современных методологиях разработки игр, таких как гибкая разработка или итеративные подходы, принцип **BDUF** часто не рекомендуется.

В разработке игр применение принципа **BDUF** может иметь следующие негативные аспекты:

1. **Затраты времени и ресурсов.**  
Подготовка детального дизайна заранее может потребовать значительных усилий и затрат времени, особенно если проект находится в начальной стадии, когда многие аспекты игры еще неопределены.

2. **Ограничение гибкости и изменений.**  
**BDUF** предполагает, что все аспекты проекта определены и запланированы заранее. Однако, при разработке игр часто возникают необходимость внесения изменений, экспериментов и адаптации на основе обратной связи от игроков. Чрезмерное следование принципа **BDUF** может ограничить быстрое реагирование на изменения и привести к потере гибкости развития.

3. **Неэффективное использование ресурсов.**  
**BDUF** может привести к тому, что значительное количество времени и усилий будет потрачено на разработку подробного плана, который в конечном итоге может потребовать значительных изменений или оказаться неактуальным в процессе реализации.

Важно найти баланс между предварительным планированием и гибкостью в процессе разработки игр или других приложений. Использование гибких методологий, позволяет команде быстро прототипировать, тестировать и вносить изменения в игру на основе обратной связи.

### **Occam&apos;s Razor**

**Occam&apos;s Razor** – принцип бритва Оккама является одним из фундаментальных принципов в научном мышлении и философии, который также имеет применение в программировании и проектировании программного обеспечения.

Суть принципа заключается в следующем: &quot;Если есть два объяснения, равноценные по своей способности объяснить определенное явление, то предпочтение следует отдать более простому объяснению.&quot;

Применительно к программированию и проектированию программного обеспечения, принцип бритвы Оккама рекомендует выбирать наиболее простые и минимальные решения, которые могут объяснить требуемое поведение или решить задачу.

Принцип бритвы Оккама напоминает о важности избегания излишней сложности в коде и проектировании. Предпочтение отдается более простым и понятным решениям, которые легче поддерживать, отлаживать и модифицировать.

Применение принципа бритвы Оккама в программировании может помочь избежать излишних украшательств, сложных алгоритмов или неоправданной сложности в структуре программы. Вместо этого, разработчики стремятся создавать минимальные, ясные и простые решения, которые решают поставленные задачи эффективно и понятно.

Однако, важно отметить, что принцип бритвы Оккама не является жестким правилом или абсолютной истиной!

В некоторых случаях, более сложные решения могут быть необходимы из-за специфики задачи или контекста. В таких ситуациях, принцип бритвы Оккама не означает, что всегда нужно выбирать самое простое решение без учета других факторов. Важно найти баланс между простотой и функциональностью, учитывая требования проекта и его цели.

Применение принципа бритвы Оккама в программировании способствует созданию чистого, понятного и эффективного кода. Это помогает снизить сложность разработки, улучшить поддерживаемость и повысить качество программного обеспечения.

Важно отметить, что принцип бритвы Оккама является руководящим принципом и не предоставляет конкретных инструкций или алгоритмов для принятия решений. Его применение требует субъективного суждения и анализа конкретной ситуации. Кроме того, он не исключает необходимость дальнейшего исследования, экспериментов и проверки гипотез для достижения оптимальных результатов.

В разработке игр, принцип **Occam&apos;s Razor** может быть применен следующим образом:

1. **Простота игровой механики.**  
При разработке игры стоит стремиться к созданию простых и интуитивно понятных игровых механик. Если у вас есть несколько вариантов механик для достижения одной и той же цели, предпочтение следует отдавать более простому и понятному варианту. Простые механики облегчают игровой процесс и уменьшают нагрузку на игрока.

2. **Упрощение архитектуры игры.**  
При проектировании архитектуры игры, стоит предпочесть более простые и модульные решения. Использование сложных и избыточных компонентов может привести к усложнению разработки, тестирования и поддержки игры. Более простая архитектура облегчает понимание кода и повышает его поддерживаемость.

3. **Минимализм в графике и дизайне.**
При создании графического оформления и дизайна игры, принцип **Occam&apos;s Razor** может помочь выбрать более простые и минималистичные решения. Избегайте излишней сложности и детализации, если они не несут необходимой функциональности или добавляют значимого визуального эффекта. Простота дизайна способствует чистоте восприятия и позволяет игрокам легко сосредоточиться на геймплее.

Принцип **Occam&apos;s Razor** помогает избегать излишней сложности и сохранять простоту в разработке игры. Это способствует более эффективному использованию ресурсов, улучшению производительности и повышению качества игрового опыта. Данный принцип применяется в разработке игр и других приложений.

### Является ли принцип **KISS** частным случаем **Occam&apos;s Razor**?

Принцип **KISS** (Keep It Simple, Stupid) и принцип **Occam&apos;s Razor** (Принцип Бритвы Оккама) имеют сходные концептуальные корни, но они обычно применяются в разных контекстах и имеют различные акценты.

Принцип **KISS** подразумевает, что решения должны быть максимально простыми и несложными. Он чаще всего связан с проектированием и разработкой, где его цель - упростить архитектуру, код или дизайн продукта, чтобы уменьшить сложность, улучшить читаемость и облегчить поддержку. В контексте **KISS**, упрощение является конечной целью.

Принцип **Occam&apos;s Razor** берет начало из философии и науки и гласит, что &quot;не следует умножать сущности без необходимости&quot;. То есть, когда есть несколько объяснений для какого-либо явления или явления, научный подход предполагает, что более простое объяснение, требующее меньше допущений, чаще всего является предпочтительным. **Occam&apos;s Razor** широко применяется в философии, науке и логике.

Все эти принципы в совокупности помогают создавать программное обеспечение, которое не только соответствует текущим требованиям, но и готово к эволюции и изменениям в будущем.</content:encoded></item><item><title>Что такое hard skills и как их развить</title><link>https://awilum.ru/articles/hard-skills/</link><guid isPermaLink="true">https://awilum.ru/articles/hard-skills/</guid><description>Что такое hard skills и как их развить</description><pubDate>Mon, 15 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Hard skills — это конкретные навыки, которые необходимы для выполнения определенной работы или задачи. Они связаны с техническими знаниями и умениями, которые можно получить через образование, тренинги, сертификацию или практику. Например, hard skills IT специалиста могут включать программирование, тестирование, анализ данных, разработку веб-сайтов, управление проектами и т.д.


Hard skills отличаются от soft skills, которые являются более общими и трансферабельными навыками, связанными с личностными качествами, коммуникацией, эмоциональным интеллектом и взаимодействием с другими людьми. Например, soft skills IT специалиста могут включать креативность, критическое мышление, решение проблем, работу в команде, адаптацию к изменениям и т.д.


Hard skills и soft skills важны для успешной карьеры в IT сфере, так как они дополняют друг друга и помогают достигать целей. Однако, hard skills часто являются более востребованными и конкурентоспособными на рынке труда, так как их легче проверить и оценить. Кроме того, hard skills постоянно развиваются и обновляются в связи с быстрым темпом технологического прогресса, поэтому IT специалистам необходимо постоянно учиться и совершенствоваться в своей области.


Как развить hard skills IT специалисту
Развитие hard skills IT специалисту зависит от нескольких факторов, таких как уровень опыта, интересы, цели, доступность ресурсов и времени.


Можно выделить следующие шаги для развития hard skills IT специалисту:

1. Определить свои сильные и слабые стороны в hard skills, а также потребности и ожидания работодателей или клиентов. Для этого можно использовать различные инструменты, такие как тесты, опросы, анкеты, обратная связь, анализ вакансий и т.д.
2. Выбрать hard skills, которые хочется развить или улучшить, исходя из своих интересов, целей, рыночных трендов и перспектив карьерного роста. Для этого можно провести исследование, консультацию, менторство, сетевое взаимодействие и т.д.
3. Найти подходящие ресурсы для обучения и практики hard skills, такие как курсы, книги, видео, вебинары, статьи, блоги, подкасты, онлайн-платформы, проекты, хакатоны и т.д. Для этого можно учитывать свой бюджет, график, стиль обучения и предпочтения.
4. Составить план обучения и практики hard skills, установив конкретные, измеримые, достижимые, реалистичные и ограниченные по времени цели, а также определив стратегии, методы, индикаторы и критерии успеха. Для этого можно использовать различные техники, такие как SMART, OKR, KPI, SWOT и т.д.
5. Выполнять план обучения и практики hard skills, регулярно изучая новую информацию, применяя полученные знания и умения на практике, отслеживая свой прогресс и результаты, получая и анализируя обратную связь, корректируя свои действия и т.д. Для этого можно использовать различные инструменты, такие как приложения, журналы, портфолио, сертификаты, рекомендации и т.д.
6. Оценить свой уровень hard skills, сравнивая свои достижения с поставленными целями, а также с требованиями и стандартами работодателей или клиентов. Для этого можно использовать различные методы, такие как экзамены, тесты, интервью, аудит, ревью и т.д.
7. Поддерживать и улучшать свои hard skills, постоянно следя за новыми технологиями, тенденциями в IT сфере, а также участвуя в различных профессиональных сообществах, мероприятиях, обучениях и т.д.</content:encoded></item><item><title>Разница между простым и строгим равенством в JavaScript</title><link>https://awilum.ru/articles/difference-between-simple-and-strict-equality-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/difference-between-simple-and-strict-equality-in-javascript/</guid><description>Разница между простым и строгим равенством в JavaScript</description><pubDate>Sun, 14 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
В JavaScript есть два оператора сравнения для проверки равенства: `==` (простое равенство) и `===` (строгое равенство). Разница между ними заключается в том, как они обрабатывают типы данных.

### Простое равенство `==`

Преобразует операнды к одному типу (если они разных типов) перед сравнением.

Например, если один операнд строка, а другой число, JavaScript попытается преобразовать строку в число перед сравнением.

Пример:

```javascript
console.log(5 == &quot;5&quot;); // true, потому что строка &quot;5&quot; преобразуется в число 5
```

### Строгое равенство `===`

Сравнивает значения и типы данных операндов без их преобразования.

Возвращает `true` только в том случае, если значения и типы обоих операндов идентичны.

Пример:

```javascript
console.log(5 === &quot;5&quot;); // false, так как значения равны, но типы разные (число и строка)
```

Использование строгого равенства `===` обычно рекомендуется, так как оно предотвращает неявные преобразования типов и делает код более предсказуемым. </content:encoded></item><item><title>Список ключевых слов и зарезервированных слов в JavaScript</title><link>https://awilum.ru/articles/list-of-keywords-and-reserved-words-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/list-of-keywords-and-reserved-words-in-javascript/</guid><description>Список ключевых слов и зарезервированных слов в JavaScript</description><pubDate>Sat, 13 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
В JavaScript существует определенный набор ключевых слов и зарезервированных слов, которые имеют специальное значение и не могут быть использованы в качестве идентификаторов (например, имен переменных, функций и т. д.). 

Вот список ключевых и зарезервированных слов в JavaScript:

&lt;table align=&quot;center&quot; style=&quot;width:100%&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;abstract&lt;/td&gt;
			&lt;td&gt;arguments&lt;/td&gt;
			&lt;td&gt;await*&lt;/td&gt;
			&lt;td&gt;boolean&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;break&lt;/td&gt;
			&lt;td&gt;byte&lt;/td&gt;
			&lt;td&gt;case&lt;/td&gt;
			&lt;td&gt;catch&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;char&lt;/td&gt;
			&lt;td&gt;class*&lt;/td&gt;
			&lt;td&gt;const&lt;/td&gt;
			&lt;td&gt;continue&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;debugger&lt;/td&gt;
			&lt;td&gt;default&lt;/td&gt;
			&lt;td&gt;delete&lt;/td&gt;
			&lt;td&gt;do&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;double&lt;/td&gt;
			&lt;td&gt;else&lt;/td&gt;
			&lt;td&gt;enum*&lt;/td&gt;
			&lt;td&gt;eval&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;export*&lt;/td&gt;
			&lt;td&gt;extends*&lt;/td&gt;
			&lt;td&gt;false&lt;/td&gt;
			&lt;td&gt;final&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;finally&lt;/td&gt;
			&lt;td&gt;float&lt;/td&gt;
			&lt;td&gt;for&lt;/td&gt;
			&lt;td&gt;function&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;goto&lt;/td&gt;
			&lt;td&gt;if&lt;/td&gt;
			&lt;td&gt;implements&lt;/td&gt;
			&lt;td&gt;import*&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;in&lt;/td&gt;
			&lt;td&gt;instanceof&lt;/td&gt;
			&lt;td&gt;int&lt;/td&gt;
			&lt;td&gt;interface&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;let*&lt;/td&gt;
			&lt;td&gt;long&lt;/td&gt;
			&lt;td&gt;native&lt;/td&gt;
			&lt;td&gt;new&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;null&lt;/td&gt;
			&lt;td&gt;package&lt;/td&gt;
			&lt;td&gt;private&lt;/td&gt;
			&lt;td&gt;protected&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;public&lt;/td&gt;
			&lt;td&gt;return&lt;/td&gt;
			&lt;td&gt;short&lt;/td&gt;
			&lt;td&gt;static&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;super*&lt;/td&gt;
			&lt;td&gt;switch&lt;/td&gt;
			&lt;td&gt;synchronized&lt;/td&gt;
			&lt;td&gt;this&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;throw&lt;/td&gt;
			&lt;td&gt;throws&lt;/td&gt;
			&lt;td&gt;transient&lt;/td&gt;
			&lt;td&gt;true&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;try&lt;/td&gt;
			&lt;td&gt;typeof&lt;/td&gt;
			&lt;td&gt;var&lt;/td&gt;
			&lt;td&gt;void&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;volatile&lt;/td&gt;
			&lt;td&gt;while&lt;/td&gt;
			&lt;td&gt;with&lt;/td&gt;
			&lt;td&gt;yield&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

Слова, отмеченные *, являются новыми в ECMAScript 5 и ECMAScript 6.</content:encoded></item><item><title>Как соединить две строки в PHP?</title><link>https://awilum.ru/articles/how-to-join-two-strings-in-php/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-join-two-strings-in-php/</guid><description>Как соединить две строки в PHP</description><pubDate>Fri, 12 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
В PHP для объединения двух строк используется оператор точки `.`. 

Этот оператор служит для соединения значений строковых переменных или строковых литералов. 

Вот пример использования:

```php
&lt;?php
// Две строки для объединения
$str1 = &quot;Привет, &quot;;
$str2 = &quot;мир!&quot;;

// Используем оператор точки для соединения строк
$result = $str1 . $str2;

// Вывод результата
echo $result; // Привет, мир!
```
В этом примере `$str1` содержит строку `Привет, `, `$str2` содержит строку `&quot;мир!&quot;`, и оператор точки используется для объединения этих двух строк в переменной `$result`. После выполнения этого кода, переменная `$result` будет содержать строку `Привет, мир!`, которая затем выводится с помощью `echo`.

Оператор точки в PHP может использоваться не только для соединения строк, но и для соединения любых выражений, возвращающих строковые значения.

В PHP существуют и другие способы объединения строк, помимо использования оператора точки `.`

### Использование оператора присваивания с точкой

```php
&lt;?php
// Две строки для объединения
$str1 = &quot;Привет, &quot;;
$str2 = &quot;мир!&quot;;

// Используем оператор присваивания с точкой для объединения строк
$str1 .= $str2;

// Вывод результата
echo $str1; // Привет, мир!
```

В этом примере `$str1` объединяется с `$str2` с использованием оператора присваивания с точкой `.`

Этот способ изменяет значение переменной `$str1`, добавляя к ней содержимое переменной `$str2`.

### Функция `sprintf`

```php
&lt;?php
// Две строки для объединения
$str1 = &quot;Привет, &quot;;
$str2 = &quot;мир!&quot;;

// Используем функцию sprintf для форматирования и объединения строк
$result = sprintf(&quot;%s%s&quot;, $str1, $str2);

// Вывод результата
echo $result; // Привет, мир!
```

Функция `sprintf` позволяет форматировать строки с использованием специальных меток. В этом примере `%s` означает строку, и две такие метки используются для объединения строк.

### Интерполяция строк 

```php
&lt;?php
// Две строки для объединения
$str1 = &quot;Привет, &quot;;
$str2 = &quot;мир!&quot;;

// Используем интерполяцию строк для объединения
$result = &quot;$str1$str2&quot;;

// Вывод результата
echo $result;
```

В этом примере строки объединяются непосредственно внутри строки с использованием синтаксиса интерполяции строк.


</content:encoded></item><item><title>Как соединить две строки в JavaScript?</title><link>https://awilum.ru/articles/how-to-join-two-strings-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-join-two-strings-in-javascript/</guid><description>Как соединить две строки в JavaScript</description><pubDate>Thu, 11 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
В JavaScript есть несколько способов объединения двух строк. 

### Использование оператора `+`

Простейший способ объединить две строки - использовать оператор `+`.  
Он может быть использован для объединения строк или строки с другими типами данных.

```javascript
let str1 = &quot;Привет, &quot;;
let str2 = &quot;мир!&quot;;
let result = str1 + str2;

console.log(result); // Привет, мир!
```

Обратите внимание, что если одно из значений не является строкой, JavaScript автоматически попытается преобразовать его в строку.

### Использование метода `concat()`

Метод `concat()` предоставляет альтернативный способ объединения строк. Он может принимать неограниченное количество аргументов и объединяет их вместе.

```javascript
let str1 = &quot;Привет, &quot;;
let str2 = &quot;мир!&quot;;
let result = str1.concat(str2);

console.log(result); // Привет, мир!
```

Также вы можете передавать несколько аргументов:

```javascript
let str1 = &quot;Привет, &quot;;
let str2 = &quot;мир!&quot;;
let str3 = &quot; Как дела?&quot;;
let result = str1.concat(str2, str3);

console.log(result); // Привет, мир! Как дела?
```

### Использование шаблонных строк (Template Strings)

С использованием шаблонных строк можно более удобно встраивать переменные и выражения в строки.

```javascript 
let str1 = &quot;Привет, &quot;;
let str2 = &quot;мир!&quot;;
let result = `${str1}${str2}`;

console.log(result); // Привет, мир!
```

Здесь `${}` используется для вставки переменных в строку.</content:encoded></item><item><title>Как проверить, является ли значение числом в JavaScript</title><link>https://awilum.ru/articles/how-to-check-if-a-value-is-a-number-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-check-if-a-value-is-a-number-in-javascript/</guid><description>Как проверить, является ли значение числом в JavaScript</description><pubDate>Wed, 10 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
В JavaScript существует несколько способов проверки, является ли значение числом. 

### Использование `typeof`

Самый простой и быстрый способ проверки типа значения в JavaScript - использовать оператор `typeof`. Он возвращает строку, представляющую тип операнда.

```javascript
let value = 42;

if (typeof value === &apos;number&apos;) {
    console.log(&apos;Значение является числом&apos;);
} else {
    console.log(&apos;Значение не является числом&apos;);
}

// Значение является числом
```

### Использование `isNaN()`

Функция `isNaN()` используется для проверки того, является ли значение `NaN` (Not a Number). Однако, она также может быть использована для определения, является ли значение числом.

```javascript
let value = 42;

if (!isNaN(value)) {
    console.log(&apos;Значение является числом&apos;);
} else {
    console.log(&apos;Значение не является числом&apos;);
}

// Значение является числом
```

Этот метод может быть использован для чисел, но имейте в виду, что он вернет `true` для значений, которые могут быть преобразованы в числа. 

Вот еще несколько примеров того как работает функция `isNaN()` с различными входным значениями:
```javascript
console.log(!isNaN(42))      // true
console.log(!isNaN(&quot;42&quot;))    // true
console.log(!isNaN(&quot;Hello&quot;)) // false
console.log(!isNaN({}))      // false
console.log(!isNaN([]))      // true
console.log(!isNaN(&quot;&quot;))      // true
console.log(!isNaN(1.2))     // true
```
</content:encoded></item><item><title>Удалить все node_modules</title><link>https://awilum.ru/articles/delete-all-node-modules/</link><guid isPermaLink="true">https://awilum.ru/articles/delete-all-node-modules/</guid><description>Удалить все node_modules</description><pubDate>Tue, 09 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Если вы разрабатываете приложение на Node.js, вы, вероятно, знакомы с папкой `node_modules`. Эта папка содержит все зависимости вашего проекта (проектов), и она может занимать много места на диске. Иногда вам может потребоваться удалить все `node_modules` из-за различных причин, таких как освобождение места на диске, очистка проекта перед публикацией или просто из-за проблем с зависимостями. 

### С использованием `npkill`

Этот полезный инструмент позволяет вам найти любые устаревшие каталоги `node_modules` в вашей системе, которые вы можете легко удалить.

Установить его можно выполнив команду в консоли:
```bash
npm i -g npkill
```

Запустить:
```bash
npx npkill
```

![](https://npkill.js.org/img/start%20search.gif)

Страница проекта: https://npkill.js.org/

### Альтернативынй вариант (Linux &amp; Mac)

Вывести список каталогов, которые будут удалены:

```bash
find . -name &apos;node_modules&apos; -type d -prune
```

Удалить каталоги из текущего рабочего каталога:

```bash
find . -name &apos;node_modules&apos; -type d -prune -exec rm -rf &apos;{}&apos; +
```</content:encoded></item><item><title>Как узнать версию PHP?</title><link>https://awilum.ru/articles/how-to-find-out-the-version-of-php/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-find-out-the-version-of-php/</guid><description>Как узнать версию PHP?</description><pubDate>Mon, 08 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
### Использование команды PHP в командной строке:

Откройте терминал/командную строку, введите следующую команду и нажмите клавишу `Enter`:

```
php -v
```

### С использованием PHP

Вы можете воспользоваться следующим кодом в PHP файле:

```php
&lt;?php
    phpinfo();
?&gt;
```

</content:encoded></item><item><title>Как узнать версию Node.js?</title><link>https://awilum.ru/articles/how-to-find-out-the-version-of-nodejs/</link><guid isPermaLink="true">https://awilum.ru/articles/how-to-find-out-the-version-of-nodejs/</guid><description>Как узнать версию Node.js?</description><pubDate>Sun, 07 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
### Команда в терминале/командной строке

Откройте терминал (в Linux/Mac) или командную строку (в Windows) и введите следующую команду:

```
node -v
```

### С использованием JavaScript

Вы можете воспользоваться следующим кодом в JavaScript файле или в REPL:

```
console.log(process.version);
```

</content:encoded></item><item><title>Выбор регистра букв для имен констант в JavaScript</title><link>https://awilum.ru/articles/selecting-letter-case-for-constant-names-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/selecting-letter-case-for-constant-names-in-javascript/</guid><description>Выбор регистра букв для имен констант в JavaScript</description><pubDate>Sat, 06 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Именование констант в JavaScript обычно делается с помощью `camelCase` формата или другого установленного руководством по стилю. 

Пример: `myConstantVariable`

Константы называются с использованием заглавных букв и подчеркивания `SNAKE_CASE` в тех случаях, когда они представляют собой &quot;константные&quot; значения, которые не должны изменяться. 

Пример: `MAX_VALUE`

Так же в JavaScript существует соглашение, согласно которому имена констант, которые предназначены для внутреннего использования внутри функций или модулей, могут начинаться с символа подчеркивания. 

Пример: `_privateConstant`

Если рассмотреть такие вот примеры `const OPTIONS = {}` или `const options = {}`

`UPPER_CASE` (заглавные буквы) — обычно это стиль именования, который используется для именования констант, т.е. значений, которые не должны изменяться после их определения. 

Если ваш объект `OPTIONS` представляет собой константу и не предполагается, что его значения будут изменяться:

```javascript
const OPTIONS = {
  key1: &apos;value1&apos;,
  key2: &apos;value2&apos;
};
```

`camelCase` (верблюжий регистр) — если ваш объект `options` представляет собой обычный объект, значения в котором могут изменяться, то обычно используют верблюжий стиль `camelCase` для именования переменных (включая константные):

```javascript
const options = {
  key1: &apos;value1&apos;,
  key2: &apos;value2&apos;
};
```

Этот стиль удобен, если вы планируете изменять или обновлять значения внутри объекта `options`.

Еще пример с циклом `for`:


```javascript
const MAX_ITERATIONS = 5;

for (let i = 0; i &lt; MAX_ITERATIONS; i++) {
  console.log(i);
}
```

В этом примере `MAX_ITERATIONS` объявлена как константа с помощью `const`, и значение этой константы составляет 5.

`MAX_ITERATIONS` в этом примере остается константой на протяжении всего выполнения цикла. Если бы вы попытались изменить ее значение внутри цикла, это вызвало бы ошибку, так как константы нельзя переназначить после их определения с использованием `const`.

В JavaScript нет жестких правил для именования объектов. Главное — следовать соглашениям в вашей команде или проекте, чтобы обеспечить последовательность и читаемость кода.

</content:encoded></item><item><title>Разница между методом forEach() и map() в JavaScript</title><link>https://awilum.ru/articles/difference-between-foreach-and-map-method-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/difference-between-foreach-and-map-method-in-javascript/</guid><description>Разница между методом forEach() и map() в JavaScript</description><pubDate>Fri, 05 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Методы `forEach()` и `map()` являются методами массивов и выполняют итерацию по элементам массива.

Метод `map()` создаёт новый массив с результатом вызова указанной `callback` функции для каждого элемента массива.

Обновление массива позиций игроков:
```javascript
let playerPositions = [
  { x: 10, y: 20 },
  { x: 20, y: 30 },
  { x: 30, y: 40 }
];

let updatedPositions = playerPositions.map(pos =&gt; ({ x: pos.x + 5, y: pos.y + 10 }));

console.log(updatedPositions);

/*

[[object Object] {
  x: 15,
  y: 30
}, [object Object] {
  x: 25,
  y: 40
}, [object Object] {
  x: 35,
  y: 50
}]

*/
```

Метод `forEach()` выполняет `callback` функцию для каждого элемента в массиве.

Обновление позиции каждого юнита-врага в массиве:
```javascript
let enemies = [
  { name: &quot;Гоблин&quot;, x: 100, y: 50 },
  { name: &quot;Скелет&quot;, x: 200, y: 100 },
  { name: &quot;Орк&quot;, x: 300, y: 150 }
];

enemies.forEach(enemy =&gt; {
  enemy.x += 10;
  enemy.y += 5;
});

console.log(enemies);

/*
[[object Object] {
  name: &quot;Гоблин&quot;,
  x: 110,
  y: 55
}, [object Object] {
  name: &quot;Скелет&quot;,
  x: 210,
  y: 105
}, [object Object] {
  name: &quot;Орк&quot;,
  x: 310,
  y: 155
}]
*/
```

Основное отличие между `forEach()` и `map()` заключается в том, что `forEach()` используется, когда нужно выполнить действие для каждого элемента массива, в то время как `map()` используется, чтобы создать новый массив, преобразовывая каждый элемент исходного массива.

Пример с `map()`:

```javascript 
let enemies = [
  { name: &quot;Гоблин&quot;, x: 100, y: 50 },
  { name: &quot;Скелет&quot;, x: 200, y: 100 },
  { name: &quot;Орк&quot;, x: 300, y: 150 }
];

let result = enemies.map(pos =&gt; ({ x: pos.x + 5, y: pos.y + 10 })).filter(pos =&gt; pos.x &gt; 200)

console.log(result);

// [ { x: 205, y: 110 }, { x: 305, y: 160 } ]
```

Пример с `forEach()`:

```javascript
let enemies = [
  { name: &quot;Гоблин&quot;, x: 100, y: 50 },
  { name: &quot;Скелет&quot;, x: 200, y: 100 },
  { name: &quot;Орк&quot;, x: 300, y: 150 }
];

let result = enemies.forEach(pos =&gt; ({ x: pos.x + 5, y: pos.y + 10 })).filter(pos =&gt; pos.x &gt; 200)

console.log(result);

// TypeError: Cannot read properties of undefined (reading &apos;filter&apos;)
```</content:encoded></item><item><title>Разница между методом some() и every() в JavaScript</title><link>https://awilum.ru/articles/difference-between-some-and-every-method-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/difference-between-some-and-every-method-in-javascript/</guid><description>Разница между методом some() и every() в JavaScript</description><pubDate>Thu, 04 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Метод `some()` проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.

Пример:
```javascript
let arr = [4, 5, 8, 4, 4];

function isBiggerThan5(element, index, array) {
  return element &gt; 5;
}

function isLessThan3(element, index, array) {
  return element &lt; 3;
}

console.log(arr.some(isBiggerThan5)); // true
console.log(arr.some(isLessThan3));   // false
```

Метод `every()` проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.

Определяем все ли числа в массиве четные:
```javascript
let numbers = [2, 4, 6, 8, 10];
let allEven = numbers.every((num) =&gt; num % 2 === 0);

console.log(allEven); // true
```

Проверяем все ли элементы в массиве больше определенного значения:
```javascript
let nums = [10, 20, 30, 40, 50];
let allGreater = nums.every((num) =&gt; num &gt; 5);

console.log(allGreater); // true
```

Проверяем удовлетворяют ли все элементы массива нескольким условиям:
```javascript
let arr = [
    { name: &quot;Лия&quot;, age: 21 },
    { name: &quot;Макс&quot;, age: 19 },
    { name: &quot;Майкл&quot;, age: 19 },
];

let allMatch = arr.every((person) =&gt; person.age &gt; 18 &amp;&amp; person.name.length &gt; 2);

console.log(allMatch); // true
```

Методы `some()` и `every()` используются для проверки условий в массиве. Они возвращают булево значение (`true` или `false`) в зависимости от результата проверки.

Пример:
```javascript 
let numbers = [1, 2, 3, 4, 5];

console.log(numbers.every(num =&gt; num % 2 === 0)); // false
console.log(numbers.some(num =&gt; num % 2 === 0));  // true
```</content:encoded></item><item><title>Сортировки массивов в JavaScript</title><link>https://awilum.ru/articles/sort-array-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/sort-array-in-javascript/</guid><description>Сортировки массивов в JavaScript</description><pubDate>Wed, 03 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Метод `sort()` является встроенным методом массивов в JavaScript и предназначен для сортировки элементов массива. 

```javascript
let items = [&quot;Меч&quot;, &quot;Щит&quot;, &quot;Свиток&quot;, &quot;Кольцо&quot;];

items.sort();

console.log(items); // [&quot;Кольцо&quot;, &quot;Меч&quot;, &quot;Свиток&quot;, &quot;Щит&quot;]
```

По умолчанию метод `sort()` сортирует элeменты массива как строки по возрастанию.
Для того чтобы сортировать элeменты массива по убыванию, можно использовать дополнительно метод `reverse()`

```javascript
let items = [&quot;Меч&quot;, &quot;Щит&quot;, &quot;Свиток&quot;, &quot;Кольцо&quot;];

items.sort().reverse();

console.log(items); // [&quot;Щит&quot;, &quot;Свиток&quot;, &quot;Меч&quot;, &quot;Кольцо&quot;]
```

По умолчанию метод `sort()` сортирует элементы массива как строки в лексикографическом порядке, что может быть не всегда желательным для чисел. В этом случае необходимо использовать функцию.

```javascript 
let nums = [2, 3, 1, 4, 5];

console.log(nums.sort((a, b) =&gt; a - b)); // По возрастанию [1, 2, 3, 4, 5]
console.log(nums.sort((a, b) =&gt; b - a)); // По убыванию    [5, 4, 3, 2, 1]
```</content:encoded></item><item><title>Поиск символа в строке JavaScript</title><link>https://awilum.ru/articles/finding-a-character-in-a-string-in-javascript/</link><guid isPermaLink="true">https://awilum.ru/articles/finding-a-character-in-a-string-in-javascript/</guid><description>Методы поиска символа в строке JavaScript</description><pubDate>Tue, 02 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Если нужно найти символ в строке на JavaScript, можно воспользоваться одним из следующих методов.

### Метод `indexOf()`

Метод `indexOf()` возвращает индекс (позицию) первого вхождения указанного символа или подстроки в строке. Если символ не найден, возвращается -1.

```javascript
let myString = &quot;Hello, World!&quot;;
let charToFind = &quot;W&quot;;
let indexOfChar = myString.indexOf(charToFind);

if (indexOfChar !== -1) {
  console.log(`Символ &quot;${charToFind}&quot; найден на позиции ${indexOfChar}.`);
} else {
  console.log(`Символ &quot;${charToFind}&quot; не найден в строке.`);
}

// Символ &quot;W&quot; найден на позиции 7.
```

### Метод `includes()`

Метод `includes()` возвращает true, если указанный символ или подстрока присутствует в строке, и false в противном случае.


```javascript
let myString = &quot;Hello, World!&quot;;
let charToFind = &quot;W&quot;;

if (myString.includes(charToFind)) {
  console.log(`Символ &quot;${charToFind}&quot; найден в строке.`);
} else {
  console.log(`Символ &quot;${charToFind}&quot; не найден в строке.`);
}

// Символ &quot;W&quot; найден в строке.
```

### Метод `search()`

Метод `search()` возвращает индекс первого вхождения указанного символа или подстроки в строке. Если символ не найден, возвращается -1. В отличие от `indexOf()`, `search()` может принимать регулярные выражения.


```javascript
let myString = &quot;Hello, World!&quot;;
let charToFind = /W/;
let indexOfChar = myString.search(charToFind);

if (indexOfChar !== -1) {
  console.log(`Символ &quot;${charToFind.source}&quot; найден на позиции ${indexOfChar}.`);
} else {
  console.log(`Символ &quot;${charToFind.source}&quot; не найден в строке.`);
}

// Символ &quot;W&quot; найден в строке.
```
Мы используем `.source` для получения строкового представления регулярного выражения без слешей. </content:encoded></item><item><title>Поиск символа в строке PHP</title><link>https://awilum.ru/articles/finding-a-character-in-a-string-in-php/</link><guid isPermaLink="true">https://awilum.ru/articles/finding-a-character-in-a-string-in-php/</guid><description>Способы поиска символа в строке PHP</description><pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate><content:encoded>
Если нужно найти символ в строке на PHP, можно воспользоваться одним из следующих способов.

### Использование функции `strpos()`

Функция `strpos()` предоставляет простой и удобный способ выполнения поиска подстроки в строке. Она возвращает позицию первого вхождения искомого символа или подстроки. 

```php
&lt;?php

$string = &quot;Hello World&quot;;
$needle = &quot;W&quot;;

$position = strpos($string, $needle);

if ($position !== false) {
    echo &quot;Символ &apos;$needle&apos; найден на позиции $position&quot;;
} else {
    echo &quot;Символ &apos;$needle&apos; не найден в строке&quot;;
}

// Символ &apos;W&apos; найден на позиции 6
```

### Использование функции `mb_strpos()` для многобайтовых символов

Если ваша строка содержит многобайтовые символы (например, в UTF-8), рекомендуется использовать функцию `mb_strpos()`, чтобы избежать проблем с корректным определением позиции символов.

```php
&lt;?php

$string = &quot;Пример текста для поиска&quot;;
$needle = &quot;т&quot;;

$position = mb_strpos($string, $needle);

if ($position !== false) {
    echo &quot;Символ &apos;$needle&apos; найден на позиции $position&quot;;
} else {
    echo &quot;Символ &apos;$needle&apos; не найден в строке&quot;;
}

// Символ &apos;т&apos; найден на позиции 7
```
&lt;br&gt;

Есть еще функции `stripos()` и `mb_stripos()`. Эти функции в PHP используется для поиска первого вхождения подстроки в строке без учёта регистра символов. Они подобны `strpos()` и `mb_strpos()`, но нечувствительны к регистру символов.</content:encoded></item><item><title>Язык программирования как инструмент программиста</title><link>https://awilum.ru/articles/programming-language-as-a-developers-tool/</link><guid isPermaLink="true">https://awilum.ru/articles/programming-language-as-a-developers-tool/</guid><description>Узнайте, почему гибкие навыки так важны для разработчика. Статья расскажет о влиянии личностных качеств на успешное взаимодействие в команде и достижение целей в IT.</description><pubDate>Thu, 30 Nov 2023 00:00:00 GMT</pubDate><content:encoded>
В мире разнообразных языков программирования программисту приходится сталкиваться с постоянным выбором подходящего инструмента для решения конкретных задач. Важность правильного выбора языка программирования трудно переоценить, поскольку это непосредственно влияет на эффективность, удобство разработки и конечное качество программного продукта.  

В данной статье я рассмотрю, почему программист должен рассматривать язык программирования как инструмент, а не просто как набор синтаксических правил.  

### Соответствие задаче
Как и в любой другой области, правильный инструмент зависит от поставленной задачи. Различные языки программирования спроектированы для решения разнообразных проблем.  

Например, язык программирования Python стал неоспоримым лидером в области быстрого прототипирования и анализа данных. Его лаконичный и выразительный синтаксис делает код читаемым и понятным, а обширная стандартная библиотека предоставляет готовые решения для многих задач. В этом контексте Python является идеальным инструментом для разработки прототипов и решения задач машинного обучения.  

С другой стороны, C++ остается непревзойденным в области системного программирования и высокопроизводительных приложений. Его низкоуровневые возможности дают программистам полный контроль над ресурсами компьютера, что является критическим для создания эффективных и масштабируемых систем. Крупные проекты, такие как игры или операционные системы, часто выбирают C++ из-за его производительности и гибкости.  

Тем не менее, разнообразие выбора не ограничивается только Python и C++. Например, JavaScript широко применяется в веб-разработке благодаря своей способности взаимодействовать с браузерами, тогда как Ruby известен своей простотой и элегантностью, что делает его предпочтительным для разработки веб-приложений.  

Не стоит забывать и о языке Go, который заявляет о себе как о языке, спроектированном специально для создания надежных и эффективных серверных приложений.  

### Продуктивность программиста
Выбор правильного языка программирования может существенно повлиять на продуктивность разработчика. Если язык предоставляет удобные средства разработки, богатую стандартную библиотеку и эффективные инструменты отладки, программист может сосредоточиться на решении конкретных задач, минимизируя время, затраченное на рутинные операции.  

Рациональный выбор языка программирования оказывает глубокое воздействие на трудовую продуктивность разработчика. Удобные средства разработки, обширные стандартные библиотеки и эффективные инструменты отладки становятся неотъемлемыми компонентами, позволяющими программисту фокусироваться на сущности задачи, сокращая время, затрачиваемое на монотонные операции.   

Рассмотрим, например, язык программирования Java, который блестяще подходит для крупных корпоративных приложений. Его кроссплатформенность и обширная библиотека делают его отличным выбором для разработки надежных и масштабируемых систем. Компоненты обеспечивают высокий уровень абстракции, снижая необходимость в подробном взаимодействии с железом и упрощая разработку.  

В контексте веб-разработки, язык программирования PHP выделяется своей специализацией на серверной стороне. Его удобство в интеграции с HTML и базами данных делает его предпочтительным выбором для создания динамических веб-сайтов. Широко применяемые фреймворки, такие как Laravel, упрощают процесс разработки, позволяя разработчикам фокусироваться на бизнес-логике.  

JavaScript, сфокусированный на клиентской стороне веб-разработки, активно используется для создания интерактивных и динамичных пользовательских интерфейсов. С появлением Node.js, JavaScript стал также применяться на серверной стороне, что дополнило его универсальность и улучшило согласованность между клиентской и серверной частями приложения.  

Необходимо также отметить Rust, язык системного программирования, который акцентирует внимание на безопасности и производительности.  

### Cообщество
Популярные языки программирования не только обретают свою популярность из-за своей эффективности, но и благодаря активным сообществам, поддерживающим их развитие. Эти сообщества становятся неиссякаемыми источниками опыта и ресурсов, что делает выбор языка программирования более стратегическим, чем просто предпочтением синтаксиса.  

Например, Java, язык, который не только широко используется в корпоративных приложениях, но и обладает многолетней историей и разветвленным сообществом. Разработчики Java имеют доступ к богатой экосистеме библиотек, фреймворков, и могут участвовать в обсуждениях на форумах и мероприятиях, что способствует их постоянному профессиональному росту.  

Аналогично, Python привлекает внимание своим разнообразием применений, начиная от анализа данных и искусственного интеллекта до веб-разработки. Огромное сообщество Python предоставляет не только обширный выбор библиотек, но и обеспечивает поддержку для начинающих программистов через онлайн-ресурсы, такие как образовательные платформы и форумы.  

JavaScript, ставший фундаментом веб-технологий, также выделяется своим активным сообществом. С появлением новых фреймворков, таких как React, Angular и Vue.js, разработчики могут обмениваться опытом и лучшими практиками, что способствует инновационному развитию в области веб-разработки.  

### Технологическая актуальность
Динамичное развитие технологий непрерывно влияет на популярность языков программирования, делая выбор инструмента еще более стратегическим для программиста. Следить за трендами в области разработки и успешно адаптироваться к новым технологиям становится неотъемлемой частью профессиональной жизни.   

Например, язык программирования Swift, разработанный Apple для создания приложений под iOS и macOS. В связи с постоянным обновлением операционных систем и внедрением новых функций, знание Swift становится ключевым для мобильных разработчиков, стремящихся оставаться в тренде и предоставлять современные функциональности в своих приложениях.  

JavaScript, находящийся в центре веб-технологий, также поддается активным изменениям. Развитие фреймворков, таких как React, Angular и Vue.js, изменяет подход к созданию интерактивных пользовательских интерфейсов. Понимание и использование этих новых инструментов становится важным компонентом профессиональной экспертизы в области веб-разработки.  

### Эффективность выполнения
Оптимизация эффективности выполнения становится критическим элементом при выборе языка программирования, особенно когда перед программистом стоит задача реализации проекта с особыми требованиями по производительности. Различные языки предлагают уникальные характеристики, которые могут определить успех проекта и обеспечить максимальную эффективность.  

Примером может служить C++, язык программирования, изначально разработанный для системного программирования. Его низкоуровневые возможности и близость к аппаратному обеспечению делают его предпочтительным выбором для разработки высокопроизводительных приложений, таких как игры или приложения реального времени.  

С другой стороны, для программирования встроенных систем часто используется язык программирования Ada. Он обладает строгой статической типизацией и управлением памятью, что позволяет предотвращать множество ошибок на этапе компиляции, обеспечивая высокую эффективность и надежность встроенных систем.   

В области высокопроизводительных вычислений часто применяется язык программирования Fortran. Его специализация на математических вычислениях и возможности оптимизации делают его особенно полезным для разработки научных приложений, требующих максимальной производительности.   

Для создания эффективных алгоритмов машинного обучения и обработки больших объемов данных может быть предпочтителен язык программирования Julia. Этот язык обеспечивает высокую производительность и удобство в работе с математическими операциями, что делает его отличным выбором в области научных исследований.  

Язык программирования – это не просто средство написания кода, а инструмент, который формирует подход к решению задач и взаимодействию с программным окружением. Рассматривая язык программирования как инструмент, программист может лучше адаптироваться к разнообразным требованиям проектов и эффективно достигать поставленных целей.  </content:encoded></item><item><title>Что такое soft skills и как их развить</title><link>https://awilum.ru/articles/soft-skills/</link><guid isPermaLink="true">https://awilum.ru/articles/soft-skills/</guid><description>Узнайте, почему гибкие навыки так важны для разработчика. Статья расскажет о влиянии личностных качеств на успешное взаимодействие в команде и достижение целей в IT.</description><pubDate>Thu, 30 Nov 2023 00:00:00 GMT</pubDate><content:encoded>
**Soft skills (Гибкие навыки)** — это набор личностных, социальных и эмоциональных качеств, которые помогают человеку успешно взаимодействовать с другими людьми и достигать своих целей.  

Для разработчика soft skills могут быть такими же важными, как и технические знания, поскольку они влияют на то, как он работает в команде, общается с клиентами, решает проблемы, управляет своим временем и адаптируется к изменениям.

В этой статье я расскажу о некоторых примерах гибких навыков (soft skills), которые полезны для разработчика, и дам вам советы, как их развивать.    

### Коммуникация
**Коммуникация** — это способность четко и убедительно выражать свои мысли, идеи и ожидания, а также слушать и понимать других.  

Для разработчика коммуникация важна, потому что он должен сотрудничать с коллегами, клиентами, менеджерами и другими заинтересованными сторонами, чтобы понять требования к проекту, обсудить решения, дать обратную связь и документировать свою работу. Хорошие коммуникативные навыки помогают избежать недопониманий, конфликтов и ошибок, а также повышают доверие и удовлетворенность.  

Чтобы улучшить свои коммуникативные навыки, вы можете:

1. Практиковаться в публичных выступлениях, например, на конференциях, митапах или внутренних презентациях. Это поможет вам научиться структурировать свою речь, адаптироваться к аудитории и справляться с волнением.

2. Использовать разные каналы общения, например, электронную почту, чат, видеозвонки или личные встречи, в зависимости от ситуации и цели. Выбирайте канал, который наиболее подходит для передачи вашего сообщения и получения обратной связи.  

3. Слушать активно и внимательно, задавать уточняющие вопросы, подтверждать понимание и давать конструктивную обратную связь. Это покажет ваш интерес и уважение к собеседнику, а также поможет избежать неправильной интерпретации или пропуска важной информации.  

4. Использовать простой и понятный язык, избегать жаргона, аббревиатур и технических терминов, если они не необходимы или не объяснены. Это сделает вашу коммуникацию более доступной и дружелюбной для людей с разным уровнем знаний и опыта.  

### Командная работа
**Командная работа** — это способность эффективно сотрудничать с другими людьми, делясь знаниями, идеями и ресурсами, а также беря на себя ответственность за общий результат.  

Для разработчика командная работа важна, потому что он часто работает в составе группы, которая может состоять из людей с разными ролями, специализациями и культурами. Хорошие навыки командной работы помогают достигать более высокого качества работы, ускорять процесс разработки, решать сложные задачи и создавать инновации.  

Чтобы улучшить свои навыки командной работы, вы можете:  

1. Участвовать в разных форматах совместной работы, например, парное программировании, код-ревью, хакатонах или сессиях мозгового штурма. Это поможет вам научиться договариваться, давать и получать обратную связь, учитывать разные точки зрения и вклады.   

2. Следовать общим правилам и стандартам работы в команде, например, использовать системы контроля версий, инструменты совместной разработки, документацию, тестирование и отладку. Это поможет вам поддерживать порядок, согласованность и надежность вашего кода, а также упростит совместную работу с другими разработчиками.   

3. Быть открытым и доброжелательным, уважать и ценить разнообразие в команде, поддерживать доверительные и долгосрочные отношения. Это поможет вам создать позитивную и продуктивную атмосферу в команде, а также улучшить свою репутацию и карьерные перспективы.  

### Решение проблем
**Решение проблем** — это способность анализировать, определять и устранять причины возникновения трудностей или несоответствий, а также находить оптимальные способы достижения желаемых результатов.  

Для разработчика решение проблем важно, потому что он постоянно сталкивается с разными вызовами, связанными с проектированием, реализацией, тестированием и сопровождением программного обеспечения. Хорошие навыки решения проблем помогают справляться с неожиданными ситуациями, улучшать качество и производительность работы, а также изобретать новые решения.  

Чтобы улучшить свои навыки решения проблем, вы можете:  

1. Применять разные методы и техники решения проблем, например, алгоритмическое мышление, логическое рассуждение, отладка, рефакторинг, реверс-инжиниринг или прототипирование. Это поможет вам систематизировать и упорядочить свой процесс решения проблем, а также выбирать наиболее подходящий метод в зависимости от задачи и контекста.

2. Использовать разные источники информации и знаний, например, документацию, учебники, статьи, видео, форумы, блоги или подкасты. Это поможет вам расширить свои знания и навыки, а также найти готовые решения или вдохновение для своих задач.  

### Управление временем
**Управление временем** — это способность планировать, организовывать и контролировать свое время, чтобы эффективно выполнять свои задачи, соблюдать сроки и достигать целей.  

Для разработчика управление временем важно, потому что он часто работает над несколькими проектами/задачами одновременно, которые могут иметь разный приоритет, сложность и объем.  

Хорошие навыки управления временем помогают справляться с нагрузкой, избегать стресса и переработки, а также повышать свою продуктивность и качество работы.  

Чтобы улучшить свои навыки управления временем, вы можете:  

1. Ставить себе реалистичные и конкретные цели, разбивать их на подзадачи и определять приоритеты. Применяйте декомпозицию, разделение целого на части. Это поможет вам сфокусироваться на самом важном и срочном, а также отслеживать свой прогресс и результаты.  

2. Использовать разные инструменты и методы планирования и организации своего времени, например, календари, планировщики, таймеры, матрицу Эйзенхауэра.
    &lt;blockquote&gt;
    &lt;strong&gt;Матрица Эйзенхауэра&lt;/strong&gt; — метод тайм-менеджмента, помогающий вычленить из всего потока дел самые важные и срочные, и распределить остальные задачи по параметрам скорости их реализации и ценности, это способствует регулированию рабочей нагрузки.
    &lt;/blockquote&gt;Это поможет вам создать свой распорядок дня, учитывая свои задачи, сроки, перерывы и другие обязательства.  

3. Оценивать и оптимизировать свою скорость и качество работы, учитывая свои сильные и слабые стороны, стиль работы, ресурсы и ограничения. Это поможет вам улучшить свою эффективность и результативность, а также избегать прокрастинации, дистракции и микроменеджмента.  

### Обучение
**Обучение** — это способность постоянно учиться новому, развивать свои знания и навыки, адаптироваться к изменениям и улучшать свою работу.  

Для разработчика обучение важно, потому что он работает в динамичной и конкурентной среде, где постоянно появляются новые технологии, тренды и требования.  

Хорошие навыки обучения помогают поддерживать свою актуальность и конкурентоспособность, а также расширять свои возможности и перспективы.  

Чтобы улучшить свои навыки обучения, вы можете:  

1. Следить за новостями и тенденциями в сфере разработки, читать статьи, журналы, блоги, подписываться на рассылки, подкасты или каналы в социальных сетях. Это поможет вам быть в курсе последних достижений и проблем в вашей области.

2. Изучать новые технологии, языки, фреймворки, библиотеки или инструменты, которые могут быть полезны для вашей работы или интересны для вас. Вы можете использовать разные ресурсы, например, онлайн-курсы, вебинары, книги, документацию или туториалы. Это поможет вам расширить свой технический стек и улучшить свои навыки.  

3. Применять и экспериментировать с тем, что вы узнали, создавая свои проекты, участвуя в хакатонах, opensource проектах. Это поможет вам закрепить свои знания, проверить свои навыки, получить обратную связь и портфолио.
    &lt;blockquote&gt;
    &lt;strong&gt;Open source проекты&lt;/strong&gt; — это программные проекты, исходные коды доступны для свободного использования, изменения и распространения общественностью. Основная идея заключается в том, чтобы предоставить открытый доступ к программному обеспечению, что позволяет сообществу разработчиков участвовать в его улучшении и расширении.
    &lt;/blockquote&gt; 
    &lt;blockquote&gt;
    &lt;strong&gt;Хакатон&lt;/strong&gt; — это событие, на котором группы разработчиков, дизайнеров и экспертов собираются в течение ограниченного времени для интенсивной совместной работы над проектами. Целью хакатона является решение определенных задач, создание новых продуктов или разработка инновационных решений.
    &lt;/blockquote&gt; 

### Креативность и гибкость
**Креативность и гибкость** — это способность придумывать новые и оригинальные идеи, решения или продукты, которые отвечают потребностям и интересам пользователей или рынка, а также способность адаптироваться к изменяющимся условиям, требованиям или обстоятельствам.  

Для разработчика креативность и гибкость важны, потому что они помогают выделяться среди конкурентов, создавать уникальную ценность и влиять на будущее технологий, а также справляться с неожиданными ситуациями, проблемами или ошибками.  

Чтобы развивать свою креативность и гибкость, вы можете:  

1. Читать, смотреть или слушать разные источники вдохновения, например, книги, фильмы, музыку, искусство, природу или истории успеха. Это поможет вам расширить свои горизонты, узнать новое и интересное, а также стимулировать свое воображение и фантазию.  

2. Участвовать в творческих проектах, играх или заданиях, например, писать стихи, рисовать, составлять головоломки, придумывать истории или персонажей. Это поможет вам тренировать свою креативность, выражать свои идеи, а также получать удовольствие и удовлетворение от своего творчества.  

3. Обмениваться своими идеями с другими людьми, например, коллегами, друзьями, семьей или сообществом. Это поможет вам получать обратную связь, советы, поддержку или критику, а также учитывать разные точки зрения, мнения и предложения.  

### Критическое мышление
**Критическое мышление** — это способность анализировать, оценивать и сравнивать разную информацию, аргументы или источники, чтобы сделать обоснованные и рациональные выводы, решения или суждения.  

Для разработчика критическое мышление важно, потому что оно помогает выбирать наиболее подходящие технологии, методы или подходы для своих задач, а также избегать ложных, непроверенных или устаревших данных.  

Чтобы развивать свое критическое мышление, вы можете:  

1. Изучать разные области знаний, например, математику, физику, химию, биологию, историю, философию или психологию. Это поможет вам развивать свою логику, рассуждение, аналитику и аргументацию, а также понимать разные законы, принципы, теории или концепции.  

2. Задавать себе и другим вопросы, например, почему, как, что, кто, где, когда или что если. Это поможет вам исследовать, проверять, уточнять и углублять свои знания, а также выявлять проблемы, противоречия, допущения или ошибки.  

3. Проверять факты и источники, например, документацию, статьи, отзывы, рейтинги или авторитетность. Это поможет вам отличать правду от лжи, факты от мнений, качество от количества, а также найти наиболее достоверную и актуальную информацию.

### Проактивность
**Проактивность** — это способность действовать инициативно, самостоятельно и ответственно, чтобы достигать своих целей, решать свои задачи и улучшать свою работу.  

Для разработчика проактивность важна, потому что она помогает быть более продуктивным, эффективным и результативным, а также показывать свою мотивацию, амбициозность и лидерство.  

Чтобы развивать свою проактивность, вы можете:

1. Ставить себе реалистичные и конкретные цели, разбивать их на подзадачи и определять приоритеты. Это поможет вам сфокусироваться на самом важном и срочном, а также отслеживать свой прогресс и результаты.

2. Действовать, а не ждать, например, начинать свои задачи как можно раньше, не откладывать их на потом, предлагать свои идеи или решения, а не ждать указаний или разрешений. Это поможет вам быть более активным, динамичным и влиятельным, а также избегать прокрастинации, пассивности или зависимости.  

3. Учиться на своих и чужих ошибках, например, анализировать, что пошло не так, как можно было сделать лучше, что можно улучшить или изменить. Это поможет вам быть более самокритичным, саморазвивающимся и самообучающимся, а также предотвращать повторение ошибок или недостатков.  

**Гибкие навыки (soft skills)** — это не менее важная часть работы разработчика, чем технические знания. Они помогают вам не только выполнять свои задачи, но и развиваться как профессионал и как личность. Поэтому я рекомендую вам постоянно работать над своими гибкими навыками, учиться у других, делиться своим опытом, и стремиться к совершенству.</content:encoded></item><item><title>Ошибка выжившего</title><link>https://awilum.ru/articles/survivorship-bias/</link><guid isPermaLink="true">https://awilum.ru/articles/survivorship-bias/</guid><description>Статья рассматривает понятие &quot;ошибка выжившего&quot; в контексте информационных технологий (IT). Описывается, как это искажение может влиять на принятие решений, основанных только на успешных кейсах, и предоставляются примеры из сферы IT. В частности, подчеркивается важность анализа не только успешных, но и неудачных опытов для более обоснованных стратегических решений в IT.</description><pubDate>Mon, 27 Nov 2023 00:00:00 GMT</pubDate><content:encoded>
Термин &quot;ошибка выжившего&quot; (Survivorship Bias) происходит из области статистики и психологии, и он может применяться к различным областям, включая IT.

Ошибкой выжившего называется искажение, которое происходит, когда мы делаем выводы на основе тех данных, которые остались &quot;выжившими&quot; после какого-то процесса, игнорируя данные о том, что не выжило. Это может привести к неверным или искаженным суждениям из-за отсутствия данных о том, что произошло с теми, кто не выжил.

Представьте, что у вас есть набор данных о том, как различные компании внедряли определенную технологию или стратегию. Анализируя успешные кейсы тех, кто добился успеха, и пытаясь выявить общие черты успеха, возникает опасность ошибки выжившего, если не учитывать компании, не достигшие успеха с тем же подходом. Например, анализ стратегий успешных компаний, внедрявших определенную технологию и ставших лидерами рынка, может привести к выводу о том, что использование этой технологии - ключ к успеху. Однако, важно также учесть опыт компаний, которые не смогли достичь успеха с этой технологией, возможно, из-за неправильной реализации или других факторов, чтобы получить более полное понимание рисков и возможностей.

Ошибка выжившего может привести к тому, что вы примените стратегию или технологию, ориентируясь только на успешные примеры, и игнорируя потенциальные риски и слабые стороны.

Следующие при эпримеры подчеркивают важность анализа полного контекста и учета не только успешных, но и неудачных опытов при принятии решений в области информационных технологий:

1. **Выбор технологических стеков на основе успешных проектов.**  
Если выбирать технологии исключительно на основе успешных кейсов, то можно упустить нюансы, связанные с уникальными требованиями проекта, спецификой команды разработчиков или изменяющейся индустрией.

2.  **Обучение на основе успешных курсов и тренингов.**  
Если программисты обучаются, ориентируясь только на курсы, которые привели к успешным карьерам других разработчиков, они могут упустить другие важные навыки или темы, которые могут быть критически важными в их конкретной сфере.

3. **Применение успешных бизнес-моделей без анализа контекста.**   
Если стартап решает использовать успешную бизнес-модель другой компании без учета специфики своего рынка, аудитории или конкурентной обстановки, это может привести к неудаче.

4. **Оценка производительности сотрудников только на основе успешных проектов.**  
Руководители, оценивающие эффективность сотрудников только по успешным проектам, могут упустить проблемы, связанные с коммуникацией, взаимодействием в команде или управлением рисками.

5. **Использование только успешных практик в области безопасности.**  
Если компания ориентируется только на успешные случаи в области кибербезопасности, она может упустить новые угрозы и методы атак, которые могут потребовать новых стратегий защиты.

Чтобы избежать ошибки выжившего, важно учитывать не только успешные случаи, но и неудачные. Анализируйте не только тех, кто добился успеха, но и тех, кто столкнулся с трудностями или не смог реализовать определенные стратегии. Это поможет вам получить более полную картину и принимать более обоснованные решения.</content:encoded></item><item><title>Зачем начинающему разработчику создавать пет-проекты</title><link>https://awilum.ru/articles/benefits-of-personal-projects-for-beginners/</link><guid isPermaLink="true">https://awilum.ru/articles/benefits-of-personal-projects-for-beginners/</guid><description>Исследование концепции пет-проекта в IT-сфере, как создание личных проектов способствует развитию навыков, углублению в технологии, и почему они важны для портфолио начинающего разработчика. Узнайте, как публичный доступ через GitHub и другие платформы может подчеркнуть ваш профессиональный потенциал.</description><pubDate>Mon, 20 Nov 2023 00:00:00 GMT</pubDate><content:encoded>
&quot;Пет-проект&quot; — это термин, используемый в IT-сфере для обозначения личного проекта или эксперимента, который разработчик выполняет по собственной инициативе и на свое усмотрение. Название происходит от словосочетания &quot;пет&quot; (pet), что означает домашнего или любимого, подчеркивая личное хобби или интерес разработчика к данному проекту.

Давайте разберем основные аспекты пет-проектов и проанализируем, как они могут положительно сказаться на карьере начинающего разработчика:

1. Пет-проект позволяет разработчику самостоятельно выбирать технологии, инструменты и задачи для решения. Это отличный способ углубиться в те темы, которые интересны именно вам.

2. Работа над пет-проектом предоставляет реальный опыт разработки, включая решение проблем, столкновение с трудностями и обучение тем аспектам разработки, которые не всегда освещаются в теоретических уроках.

3. Пет-проекты могут быть добавлены в ваше портфолио, что поможет вам выделиться среди других кандидатов при поиске работы. Работодатели часто ценят наличие реальных проектов в портфолио, так как это свидетельствует о вашей самостоятельности и способности применять знания на практике.

4. Работа над чем-то своим, даже если это маленький проект, может быть мощным источником мотивации. Этот процесс может быть увлекательным, и результат может быть источником гордости и удовлетворения.

5. В процессе работы над пет-проектом вы будете сталкиваться с различными задачами, требующими решения. Это способствует развитию практических навыков программирования, архитектурного мышления, управления проектом и других аспектов разработки.

6. Пет-проекты также могут служить площадкой для тестирования новых идей или концепций, которые вы хотели бы реализовать. Это позволяет вам экспериментировать без ограничений, что может привести к и интересным результатам.

7. В процессе работы над пет-проектом, вы можете столкнуться с необходимостью коммуникации с пользователями, обратной связи, а также управления временем и ресурсами. Это поможет в развитии [soft skills](/articles/soft-skills/), которые также ценятся в мире разработки.

8. Пет-проекты могут помочь в построении вашего личного бренда в индустрии. Если ваш проект станет популярным или будет использоваться другими разработчиками, это может повысить вашу видимость в сообществе и сделать вас признанным экспертом в определенной области.

Крайне важно обеспечить публичный доступ к вашему пет-проекту, предпочтительно на платформах таких как [GitHub](https://github.com/). В случае, если использование GitHub неприменимо, рассмотрите альтернативные варианты, такие как создание личного блога, портфолио на других сервисах или включение описания проекта в резюме при поиске работы.


Генерация идей для пет-проектов — весёлый и творческий процесс, и вот несколько источников вдохновения для начинающего разработчика:

1. Обратите внимание на свои собственные интересы и повседневные проблемы. Возможно, у вас есть идея для приложения, которое решает какую-то проблему, с которой вы лично сталкиваетесь.

2. Рассмотрите популярные приложения или веб-сайты и подумайте о том, как вы можете улучшить их. Может быть, вы можете добавить новые функции, улучшить интерфейс или оптимизировать производительность, разработать плагины или темы оформления.

3. Попробуйте создать клон известных приложений. Это может быть простым упражнением для изучения технологий и практики программирования.

4. Посмотрите задачи на платформах типа [GitHub](https://github.com/), [GitLab](https://about.gitlab.com/), или [Bitbucket](https://bitbucket.org/). Многие проекты ищут волонтёров для решения конкретных задач. Это может быть отличным способом внести свой вклад в открытое сообщество.

5. Создайте проект, который поможет вам изучить новые навыки. Например, если вы изучаете новый язык программирования и технологию, создайте простое приложение на этом языке и технологии.

6. Присоединитесь к сообществам разработчиков в социальных сетях и узнавайте, над чем работают другие. Обсуждение идей с коллегами может привести к новым интересным проектам.

7. Создайте простую игру или развлекательное приложение. Это может быть отличным способом не только развивать навыки, но и сделать процесс более увлекательным.

8. Работа на своем собственном портфолио или веб-сайте может быть отличным пет-проектом. Вы можете использовать его для демонстрации своих работ и навыков.

Не бойтесь экспериментировать и выбирать проекты, которые вам действительно интересны!</content:encoded></item><item><title>PEP 8 - Правила оформления Python-кода</title><link>https://awilum.ru/articles/pep8/</link><guid isPermaLink="true">https://awilum.ru/articles/pep8/</guid><description>Познакомьтесь с важностью соблюдения стандартов оформления Python-кода по PEP8. Улучшите читаемость, сотрудничество в команде и производительность своего Python-кода. Наша статья расскажет вам, почему следование этим правилам является ключевым фактором для успешной разработки на Python.</description><pubDate>Fri, 13 Oct 2023 00:00:00 GMT</pubDate><content:encoded>
Использование правил оформления Python-кода, известных как PEP8 (Python Enhancement Proposal 8), является важным аспектом при написании программ на языке программирования Python.

[https://pep8.org](https://pep8.org)

Вот несколько причин, почему соблюдение правил оформления PEP8 является важным:

1. **Улучшение читаемости кода.**  
Соблюдение стандартов оформления PEP8 делает код более читаемым и понятным для других разработчиков, включая вас самого. Читаемый код легко поддерживать, диагностировать и отлаживать, что упрощает разработку и снижает количество возможных ошибок.

2. **Соответствие стандартам сообщества.**  
PEP8 - это широко принятый стандарт оформления Python-кода, который поддерживается сообществом разработчиков Python. При соблюдении этих стандартов вы следуете лучшим практикам, рекомендованным сообществом, и делаете свой код более совместимым с кодом других разработчиков.

3. **Упрощение сотрудничества.**  
Если вы работаете в команде разработчиков, соблюдение правил оформления PEP8 упрощает сотрудничество и интеграцию вашего кода с кодом других разработчиков. Единый стиль оформления кода облегчает чтение, понимание и обслуживание кода разными членами команды.

4. **Снижение возможности ошибок.**  
PEP8 содержит рекомендации по структуре кода, идентификации переменных, именованию функций и методов, отступам и другим аспектам оформления. Следуя этим рекомендациям, вы можете снизить возможность допуска ошибок, таких как опечатки, неправильное именование или неправильное форматирование.

5. **Улучшение производительности.**  
Соблюдение стандартов оформления PEP8 также может улучшить производительность вашего кода. Код, написанный в соответствии с этими стандартами, более эффективно анализируется и обрабатывается инструментами автоматической обработки кода, такими как статические анализаторы или системы автоматического тестирования.

Использование правил оформления Python-кода PEP8 при написании Python программ является важным аспектом разработки на языке Python, который способствует улучшению качества кода, повышению эффективности работы и улучшению сотрудничества между разработчиками. Независимо от опыта программирования, соблюдение стандартов оформления PEP8 помогает разработчикам избежать распространенных ошибок и упрощает процесс разработки, что в конечном итоге улучшает качество продукта и сокращает время разработки. Если вы новичок в Python или уже опытный разработчик, соблюдение правил оформления PEP8 - это важный аспект разработки на языке Python, который поможет вам достичь успеха в своих Python проектах.</content:encoded></item><item><title>Технический долг</title><link>https://awilum.ru/articles/technical-debt/</link><guid isPermaLink="true">https://awilum.ru/articles/technical-debt/</guid><description>Узнайте, что такое технический долг и как он влияет на разработку ПО. Разбираем причины, последствия и методы управления. Осознайте важность приоритизации, создания плана и активного управления для повышения качества кода и надежности системы.</description><pubDate>Fri, 06 Oct 2023 00:00:00 GMT</pubDate><content:encoded>
Технический долг – это накопленные проблемы, недостатки или компромиссы в коде, дизайне или инфраструктуре разрабатываемой системы. Возможно, вы уже слышали об этом понятии, но давайте более подробно разберемся, что это значит и как он может повлиять на вашу работу.

Технический долг может возникнуть в ходе разработки ПО, когда разработчики сталкиваются с выбором между скоростью разработки и качеством кода. Иногда, чтобы успеть сдать проект в срок, приходится принимать быстрые решения, которые могут впоследствии привести к непониманию и неподдерживаемости кода, отсутствию автоматизированных тестов, а также к устаревшим зависимостям и неоптимальной архитектуре.

Подумайте о техническом долге как о долге, который вы берете на себя, чтобы ускорить разработку сейчас, но при этом вы обязуетесь вернуть в будущем, уплатив с процентами. Эти проценты – это сложности, которые будут возникать из-за неполадок в коде, плохой архитектуры или отсутствия автоматизированных тестов.

Что происходит, если мы не уделяем должного внимания техническому долгу?  

Первое и самое очевидное – это замедление скорости разработки. Когда код становится неподдерживаемым и архитектура неоптимальной, добавление новых функций или внесение изменений становится гораздо сложнее.

Технический долг может также привести к увеличению количества ошибок, что, в свою очередь, может снизить стабильность и производительность вашей системы. Кроме того, представьте себе ситуацию, когда новые разработчики присоединяются к команде. Они сталкиваются с запутанным и непонятным кодом, что затрудняет их интеграцию и усложняет процесс обучения.

После того как мы осознали, какие могут возникнуть негативные последствия из-за недостаточного уделения внимания техническому долгу, давайте перейдем к обсуждению методов его эффективного управления.

1. **Осознание.**  
Вы должны понимать, что технический долг существует и какие проблемы он может вызвать в будущем.
 
2. **Приоритизация.**  
Оцените текущее состояние вашего кода и определите, какие проблемы наиболее критичны и требуют немедленного внимания.
 
3. **Планирование.**  
Создайте план по устранению технического долга и интегрируйте его в ваш регулярный процесс разработки. Это может включать в себя рефакторинг кода, добавление автоматизированных тестов, обновление зависимостей и другие меры, направленные на улучшение качества вашего кода и архитектуры.
Кроме того, не менее важно создать культуру осознания технического долга в вашей команде. Разработчики должны понимать, что устранение долга – это неотъемлемая часть их работы, и это важно для долгосрочного успеха проекта.

Активное управление техническим долгом приносит несколько значимых преимуществ.

1. **Повышение качества и надежности вашей системы.**  
Устранение проблем и недостатков в коде и архитектуре способствует более эффективной работе вашего приложения, снижению числа ошибок и повышению удовлетворенности пользователей.
 
2. **Управление техническим долгом способствует улучшению скорости разработки.**
Чистый и поддерживаемый код позволяет быстрее внедрять новые функции и вносить изменения без риска ухудшить существующую кодовую базу. Кроме того, эффективное управление техническим долгом способствует укреплению команды разработчиков и повышению их профессиональных навыков.
Технический долг – это неотъемлемая часть процесса разработки программного обеспечения. Но важно осознавать его наличие, понимать последствия и активно управлять им для достижения успеха вашего проекта.

Помните, что регулярное устранение технического долга, создание культуры качественного кода и стремление к его непрерывному улучшению помогут создать стабильную и надежную систему, которая будет радовать пользователей и способствовать развитию вашей команды разработчиков.

И помните, каждое вложение в устранение технического долга – это инвестиция в будущее вашего проекта.
</content:encoded></item><item><title>Важность теории и практики при изучении программирования.</title><link>https://awilum.ru/articles/the-importance-of-theory-and-practice-when-learning-programming/</link><guid isPermaLink="true">https://awilum.ru/articles/the-importance-of-theory-and-practice-when-learning-programming/</guid><description>Откройте для себя идеальный баланс между теорией и практикой в обучении программированию. Узнайте, как освоить фундаментальные концепции и применять их в разработке, обеспечивая успешный путь в мире программирования.</description><pubDate>Wed, 04 Oct 2023 00:00:00 GMT</pubDate><content:encoded>

Изучение программирования – это сложный, но увлекательный процесс, требующий сочетания теоретических знаний и практического опыта. Многие начинающие программисты спрашивают: что важнее - теория или практика?

Настоящий успех в программировании достигается только при правильном балансе между этими двумя аспектами - теория или практика.

1. **Основы теории.**  
Теоретические знания в программировании являются фундаментом, на котором строится практический опыт. Изучение основных концепций, алгоритмов, структур данных и языков программирования позволяет понять принципы работы программ и разрабатывать эффективные решения. Без теоретической базы программист может оказаться ограниченным в своих возможностях и не сможет полностью понять причины возникновения проблем и ошибок.
 
2. **Практический опыт.**  
Практика - это ключевой компонент успешного обучения программированию. Решение реальных задач, разработка проектов и отладка кода позволяют применить теоретические знания на практике. Практический опыт помогает программисту развивать навыки решения проблем, креативное мышление и эффективное использование инструментов разработки. Чем больше практики, тем лучше развиваются навыки программирования и уверенность.
 
3. **Взаимосвязь теории и практики.**  
Понимание взаимосвязи между теорией и практикой является основой для эффективного обучения программированию. Теоретические знания помогают программисту прогнозировать результаты, понимать причины ошибок и выбирать подходящие методы решения задач. Практика, в свою очередь, укрепляет теоретические знания, позволяет проверить их в деле и дает возможность экспериментировать с новыми идеями. Без практики теория может остаться абстрактной и не применимой на практике, а без теории практика может быть хаотичной и неэффективной.
 
4. **Постоянное самосовершенствование.**  
Успешные программисты понимают, что изучение программирования - это непрерывный процесс самосовершенствования. Программисты постоянно обновляют свои теоретические знания, изучают новые технологии и языки программирования, а также активно применяют их на практике. Сочетание постоянного обучения и практики позволяет программистам оставаться востребованными. Теория и практика – это две неотъемлемые составляющие успешного обучения программированию.

Правильное сочетание теоретических знаний и практического опыта позволяет программистам не только понимать основы программирования, но и применять их на практике для создания качественного и эффективного кода.</content:encoded></item><item><title>Как не стать code monkey программистом</title><link>https://awilum.ru/articles/how-not-to-become-a-code-monkey-programmer/</link><guid isPermaLink="true">https://awilum.ru/articles/how-not-to-become-a-code-monkey-programmer/</guid><description>Code monkey – программист, который выполняет механические задачи по написанию кода без особого понимания или вовлеченности в широкий контекст разработки. Чтобы не превратиться в &quot;code monkey&quot; и стать опытным разработчиком, вам пригодятся следующие рекомендации.</description><pubDate>Tue, 03 Oct 2023 00:00:00 GMT</pubDate><content:encoded>

Code monkey – программист, который выполняет механические задачи по написанию кода без особого понимания или вовлеченности в широкий контекст разработки.

Чтобы не превратиться в &quot;code monkey&quot; и стать опытным разработчиком, вам пригодятся следующие рекомендации:

1. **Изучайте фундаментальные концепции программирования.**  
Понимание основных принципов и концепций программирования поможет вам создавать эффективный и качественный код. Изучите структуры данных, алгоритмы и парадигмы программирования, такие как процедурное программирование и ООП.
 
2. **Развивайте свои навыки алгоритмического мышления.**  
Научитесь решать задачи различной сложности и разрабатывать оптимальные алгоритмы. Это поможет вам развить навыки анализа, проектирования и оптимизации алгоритмов.
 
3. **Изучайте принципы проектирования и архитектуры.**  
Ознакомьтесь с принципами проектирования программного обеспечения, такими как GRASP и SOLID. Эти принципы помогут вам создавать гибкий, модульный и легко расширяемый код.
 
4. **Интересуйтесь новыми технологиями и языками программирования.**  
Будьте в курсе последних тенденций в области разработки программного обеспечения. Изучайте новые языки программирования, фреймворки и инструменты, которые могут помочь вам стать более эффективным разработчиком.
 
5. **Развивайте коммуникационные и межличностные навыки.**  
Программирование - это только одна часть работы разработчика. Хорошие коммуникационные навыки помогут вам эффективно взаимодействовать с командой, понимать требования проекта и представлять свои идеи.
 
6. **Участвуйте в открытых проектах и сообществах.**  
Принимайте участие в разработке открытого программного обеспечения и вступайте в сообщества. Вы сможете приобрести опыт работы в командной среде, а также активно обмениваться знаниями и идеями с коллегами-разработчиками.
 
7. **Продолжайте обучаться и развиваться.**  
IT-отрасль постоянно меняется, поэтому важно оставаться в курсе последних изменений. Продолжайте расширять свои знания о новых технологиях, читайте профессиональную литературу и активно участвуйте в событиях IT-индустрии.
 

Становление высококвалифицированным разработчиком требует времени, практики и постоянного обучения. Постепенно расширяйте свой набор навыков, работайте над проектами разной сложности и стремитесь к постоянному развитию.
</content:encoded></item><item><title>Улучшайте свои фундаментальные знания!</title><link>https://awilum.ru/articles/improve-your-fundamental-knowledge/</link><guid isPermaLink="true">https://awilum.ru/articles/improve-your-fundamental-knowledge/</guid><description>Освоение программирования – вызов для многих, но развитие фундаментальных знаний в математике, информатике и логике становится ключом к успешной карьере. Практика, терпение и настойчивость в учебе помогут вам преодолеть трудности и стать опытным разработчиком.</description><pubDate>Tue, 03 Oct 2023 00:00:00 GMT</pubDate><content:encoded>
Учиться программированию может быть вызовом для многих начинающих. Часто новички сталкиваются с трудностями и испытывают разочарование, особенно когда курсы кажутся им сложными. Однако, вместо того чтобы падать духом и жаловаться на сложность, важно осознать, что фундаментальные знания в математике, информатике и логике являются неотъемлемой частью успешного пути в программировании.

В этом уроке будет рассмотренно, почему развитие этих навыков может стать ключом к преодолению трудностей и достижению успеха.

Чтобы стать опытным разработчиком, вам пригодятся следующие рекомендации:

1. **Взаимосвязь математики и программирования.**  
Математика и программирование тесно связаны между собой. Математические концепции, такие как алгоритмы, логические операции и структуры данных, играют важную роль в программировании. Понимание математических принципов поможет вам анализировать и решать проблемы эффективно, а также создавать элегантные и оптимальные решения.

2. **Роль информатики в освоении программирования.**  
Информатика является основой программирования. Улучшение знаний в области информатики поможет вам понять, как компьютеры функционируют и как они обрабатывают информацию. Понимание основных концепций, таких как алгоритмы, структуры данных и архитектура компьютера, поможет вам лучше понимать работу программ и справляться с трудностями, с которыми вы столкнетесь.

3. **Развитие логического мышления.**  
Логическое мышление - одно из ключевых качеств, необходимых для программирования. Оно помогает вам анализировать проблемы, находить паттерны и создавать последовательные решения. Разработка навыков логического мышления требует практики и упорства, но это одно из самых ценных вложений времени, которые вы можете сделать. Решение математических головоломок, игра в логические игры и участие в задачах на программирование могут помочь улучшить ваше логическое мышление и способствовать преодолению трудностей в программировании.

4. **Неотъемлемость обучения и практики.**  
Хорошие фундаментальные знания в математике, информатике и логике - это результат обучения и практики. Необходимо иметь терпение и стремление к самосовершенствованию. Курсы и учебники по программированию могут предоставить вам основу, но самое важное - это ваше собственное усердие и постоянная практика. Регулярное выполнение задач и участие в проектах помогут вам применять и закреплять полученные знания.

5. **Терпение и настойчивость.**  
Важно отметить, что развитие фундаментальных знаний требует времени, усилий и настойчивости. Не ожидайте мгновенных результатов или сразу полного освоения математики, информатики и логики. Изучение этих областей может быть вызовом, и вы можете столкнуться с трудностями по пути. Однако, если вы проявляете терпение и настойчивость, вы сможете преодолеть любые трудности.

Запомните, что в программировании нет места для мгновенных решений. Изучайте теорию внимательно, делайте практические задания и не бойтесь ошибаться. Каждая ошибка и неудача - это возможность узнать что-то новое и стать лучше.

Будьте настойчивыми в своем стремлении улучшить фундаментальные знания. Если вы сталкиваетесь с проблемами, найдите дополнительные ресурсы, такие как учебники, статьи или сообщества программистов, где можно задать вопросы и получить помощь. Не бойтесь просить помощи и работать вместе с другими, чтобы расширить свои знания и навыки.

Сфокусируйтесь на улучшении ваших базовых знаний в области математики, информатики и логики. Повышение уровня этих навыков поможет вам легче освоить программирование, преодолеть трудности и достичь успеха в этой сфере. Важно помнить, что настойчивость, терпение и постоянная практика являются ключевыми качествами успешного программиста. Вкладывая усилия в развитие ваших фундаментальных знаний, вы сможете открыть для себя новые возможности в программировании и достигнуть ваших профессиональных амбиций. </content:encoded></item><item><title>Качества хорошего разработчика</title><link>https://awilum.ru/articles/qualities-of-a-good-developer/</link><guid isPermaLink="true">https://awilum.ru/articles/qualities-of-a-good-developer/</guid><description>Статья раскрывает ключевые качества успешного разработчика, такие как технические навыки, творческий подход, аналитическое мышление, самоорганизация, коммуникация, стрессоустойчивость. Узнайте, как развить навыки, стать профессионалом и справиться с вызовами в сфере разработки.</description><pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate><content:encoded>
Хороший разработчик обладает рядом качеств, которые помогают ему быть успешным в своей работе.

Вот некоторые из них:

1. **Технические навыки.**  
    Хороший разработчик должен обладать глубокими знаниями и опытом работы с соответствующими технологиями, языками программирования, фреймворками и инструментами разработки. Он должен быть в курсе последних тенденций в своей области и готов к постоянному обучению.

2. **Проблемно-ориентированное мышление.**  
    Хороший разработчик способен анализировать сложные проблемы и находить эффективные решения. Он может разбить сложную задачу на более простые и разработать план действий для их реализации.

3. **Творческий подход.**  
    Хороший разработчик может мыслить творчески и находить инновационные подходы к решению проблем. Он способен предложить новые идеи и применить свою креативность для создания эффективных и интуитивно понятных решений.

4. **Аналитическое мышление.**  
    Хороший разработчик способен анализировать требования и данные, и принимать во внимание различные факторы при принятии решений. Он умеет оценивать преимущества и недостатки различных подходов и выбирать наиболее подходящий.

5. **Самоорганизация и ответственность.**  
    Хороший разработчик должен быть самоорганизованным и ответственным. Он должен уметь управлять своим временем и приоритетами, а также выполнять задачи в срок. Ответственность и надежность важны для успешного выполнения проектов.

6. **Коммуникационные навыки и умение работать в команде.**
    Хороший разработчик способен эффективно работать в команде, сотрудничая с другими разработчиками, дизайнерами, тестировщиками и другими участниками проекта. Он должен быть готов к обмену идеями, принятию обратной связи и уметь совместно решать проблемы.

7. **Стрессоустойчивость.**  
    Разработка программного обеспечения может быть сложной и требовательной. Хороший разработчик должен быть устойчивым к стрессу и способным эффективно работать в ситуациях с ограниченными сроками и высокими требованиями.

8. **Стремление к саморазвитию.**   
    Технологии и требования в сфере разработки постоянно меняются. Хороший разработчик должен иметь стремление к постоянному саморазвитию и обучению новым инструментам и технологиям. Он должен быть готов к изучению новых языков программирования, фреймворков и методологий разработки.

9. **Стремление к качеству.**  
    Хороший разработчик ставит качество кода и конечного продукта на первое место. Он следует лучшим практикам разработки, пишет понятный и поддерживаемый код, выполняет тестирование и отладку, чтобы обеспечить высокое качество программного обеспечения.

10. **Стремление к решению проблем.**  
    Хороший разработчик активно стремится к решению проблем и находит способы улучшить существующие системы и процессы. Он ищет эффективные и инновационные решения, которые помогут достичь поставленных целей.

11. **Внимание к деталям.**  
    Хороший разработчик обладает внимательностью к деталям. Он обращает внимание на мелкие аспекты работы, такие как оптимизация кода, эффективности решения, обработка ошибок и обеспечение безопасности.

12. **Адаптивность.**  
    Технологии и требования в разработке постоянно меняются. Хороший разработчик должен быть гибким и адаптивным к новым ситуациям и изменениям.

13. **Проактивность.**  
    Хороший разработчик проявляет инициативу и самостоятельность в своей работе. Он не ожидает, что задачи будут ему назначены, а активно ищет возможности для улучшения проекта или решения проблем.

14. **Умение решать сложные задачи.**  
    Разработка программного обеспечения может включать в себя сложные задачи, требующие глубокого анализа и творческого подхода. Хороший разработчик обладает навыками разбора сложных проблем на более простые задачи и шаги, что позволяет ему эффективно решать сложные задачи.

15. **Умение работать с большими объемами информации.**  
    В процессе разработки разработчику часто приходится сталкиваться с большим объемом информации, такой как документация, спецификации или код других разработчиков. Хороший разработчик обладает навыками организации и обработки информации, чтобы быть эффективным в своей работе.

16. **Стремление к оптимизации и эффективности.**  
    Хороший разработчик не только создает работающий код, но и стремится к его оптимизации и повышению эффективности. Он ищет способы улучшить производительность, снизить нагрузку на систему и оптимизировать процессы работы.

17. **Профессионализм.**  
    Хороший разработчик относится к своей работе с профессионализмом и ответственностью. Он придерживается этических стандартов, защищает конфиденциальность данных и стремится к достижению высоких результатов.

18. **Умение обучать и делиться знаниями.**
    Хороший разработчик готов делиться своими знаниями и опытом с другими. Он может быть наставником для молодых разработчиков, помогать им расти и развиваться. Кроме того, он активно участвует в сообществе разработчиков, обменивается опытом и учится от других профессионалов.  

 
Это лишь некоторые из качеств, которыми обладает хороший разработчик.
Комбинация этих качеств позволяет разработчикам быть успешными в своей работе и достигать высоких результатов. </content:encoded></item><item><title>Роль языка программирования в создании программного обеспечения</title><link>https://awilum.ru/articles/the-role-of-programming-language-in-software-creation/</link><guid isPermaLink="true">https://awilum.ru/articles/the-role-of-programming-language-in-software-creation/</guid><description>Узнайте о важности выбора правильного языка программирования в создании программного обеспечения. Успех зависит от навыков программиста, его понимания алгоритмов и эффективного использования инструментов языка. Выберите подходящий язык для проекта и улучшите свои навыки для создания надежных решений.</description><pubDate>Wed, 27 Sep 2023 00:00:00 GMT</pubDate><content:encoded>
Язык программирования – инструмент, предназначенный для создания программного обеспечения и управления компьютером. Он служит средством передачи инструкций компьютеру, позволяя программисту описывать алгоритмы и реализовывать функциональность.

Важно понимать, что язык программирования сам по себе не является ни магическим, ни универсальным. Он предоставляет набор правил и синтаксических конструкций, с помощью которых можно создавать программы. Но именно способность программиста к применению этих конструкций, его понимание алгоритмических задач и умение решать проблемы являются основными факторами успеха.

Выбор языка программирования зависит от задачи, которую нужно решить. Разные языки предлагают разные возможности и подходы к программированию. Некоторые языки могут быть более подходящими для создания веб-приложений, другие – для научных расчетов, а еще другие – для мобильной разработки. Важно выбрать язык, который наилучшим образом соответствует требованиям проекта.

Однако даже самый мощный и эффективный язык программирования не гарантирует качественное программное обеспечение. Результат зависит от навыков программиста, его понимания алгоритмов, архитектуры и лучших практик программирования. Умение эффективно использовать инструменты языка программирования, применять модули и библиотеки, а также понимать особенности выбранного языка программирования и его ограничения - все это является неотъемлемой частью процесса разработки.

Таким образом, язык программирования – это мощный инструмент, который помогает программистам реализовывать свои идеи и создавать полезное программное обеспечение. Однако для достижения успеха необходимо иметь навыки и знания, чтобы правильно использовать этот инструмент и создавать эффективные, надежные и масштабируемые решения.
</content:encoded></item><item><title>Программирование – это не только знание языка программирования</title><link>https://awilum.ru/articles/programming-is-not-just-about-knowing-a-programming-language/</link><guid isPermaLink="true">https://awilum.ru/articles/programming-is-not-just-about-knowing-a-programming-language/</guid><description>Узнайте, что такое истинное программирование от владения языками программирования до коммуникативных навыков. Статья расскрывает важность анализа ошибок, учета особенностей области применения ПО, и необходимость эффективного сотрудничества в команде.</description><pubDate>Tue, 26 Sep 2023 00:00:00 GMT</pubDate><content:encoded>
Программирование – это не только знание языка программирования, но и умение проектировать программное обеспечение (ПО), понимать алгоритмы и структуры данных, работать с системами управления версиями, тестировать и отлаживать код, а также обладать коммуникативными навыками для работы в команде и понимания требований пользователей и заказчиков.

Важно также учитывать особенности конкретной области, в которой применяется разработанное программное обеспечение. Например, программное обеспечение для медицинских учреждений должно соответствовать требованиям законодательства и обеспечивать безопасность и конфиденциальность медицинских данных, а программное обеспечение для финансовых учреждений должно быть надежным и обеспечивать точность обработки финансовых операций.

Также в программировании важно уметь анализировать и устранять ошибки и неполадки в работе программного обеспечения. Это может включать в себя использование различных инструментов и методов для отладки кода, например, логирование или использование отладчика.

Важной составляющей программирования является умение работать с другими разработчиками и командами, включая менеджеров проектов, аналитиков данных и тестировщиков. Работа в команде может требовать умения общаться и выстраивать эффективное сотрудничество с другими участниками проекта, а также умения управлять своим временем и задачами, чтобы участвовать в достижении общих целей.

Программирование требует от разработчика широкого кругозора, творческого подхода, постоянного обучения и развития, а также умения применять свои знания и навыки на практике. Успешный разработчик программного обеспечения должен быть готов к постоянным вызовам и изменениям, которые характеризуют эту быстро развивающуюся область.
</content:encoded></item><item><title>Важность развития логического мышления для программиста</title><link>https://awilum.ru/articles/the-importance-of-developing-logical-thinking-for-a-programmer/</link><guid isPermaLink="true">https://awilum.ru/articles/the-importance-of-developing-logical-thinking-for-a-programmer/</guid><description>Откройте важность логического мышления для программиста. Логическое мышление применяется при разработке алгоритмов, отладке, повышении эффективности и разработке архитектуры программного обеспечения.</description><pubDate>Mon, 25 Sep 2023 00:00:00 GMT</pubDate><content:encoded>
Логическое мышление играет критическую роль в работе программиста. Это способность логически анализировать проблемы, разбивать их на более мелкие части, определять зависимости и взаимодействия между ними, а затем создавать эффективные алгоритмы и решения. Развитие логического мышления помогает программисту стать более компетентным и эффективным профессионалом. Вот несколько причин, почему логическое мышление важно для программиста:

1. **Разработка алгоритмов.**  
   Логическое мышление позволяет программисту разрабатывать и применять эффективные алгоритмы для решения сложных задач. Оно помогает выявить шаги, необходимые для достижения конкретной цели, и организовать их в логическую последовательность.

2. **Отладка и исправление ошибок.**  
   При разработке программ возникают ошибки, и логическое мышление помогает программисту быстро и точно определить причины возникновения проблемы. Способность логически рассуждать позволяет выявлять ошибки в коде, анализировать потоки данных и выявлять несоответствия в ожидаемом и фактическом поведении программы.

3. **Повышение эффективности.**  
   Логическое мышление помогает программисту найти наиболее оптимальные и эффективные способы решения задач. Оно позволяет анализировать различные варианты и выбирать наилучший подход, основываясь на объективных данных и требованиях проекта.

4. **Разработка архитектуры программного обеспечения.**  
   Логическое мышление необходимо при разработке архитектуры программного обеспечения. Программист должен быть способен анализировать сложные системы, определять взаимосвязи между компонентами и создавать структуры, которые будут легко поддерживаться и масштабироваться.

5. **Проектирование и тестирование.**  
   Логическое мышление помогает программисту создавать эффективные тестовые сценарии и проводить систематическое тестирование программного обеспечения. Оно также помогает в проектировании пользовательских интерфейсов, обеспечивая логическую организацию элементов и улучшая удобство использования.

Развитие логического мышления можно достичь с помощью следующих методов:

1. **Решение логических головоломок и задач.**  
   Решение головоломок и задач, требующих аналитического мышления и логических выводов, помогает развить логическое мышление. Это может быть в форме пазлов, логических игр, задач по программированию и т.д.

2. **Программирование и алгоритмические задачи.**  
   Практика программирования и решение алгоритмических задач способствуют развитию логического мышления. Участие в соревнованиях по программированию, хакатонах, может предложить сложные задачи, требующие глубокого анализа и логического рассуждения.

3. **Изучение математики и формальной логики.**  
   Математические дисциплины, такие как дискретная математика и формальная логика, развивают логическое мышление. Изучение таких предметов помогает программисту научиться строить аргументы, делать выводы и решать проблемы, основываясь на строгой логике.

4. **Анализ и обратная связь.**  
   Постоянный анализ своего кода, идентификация слабых мест и поиск способов их улучшения помогают развивать логическое мышление. Получение обратной связи от более опытных программистов также может быть ценным для развития логического мышления и улучшения навыков.

Развитие логического мышления является ключевым аспектом профессионального роста программиста. Оно позволяет решать сложные проблемы, создавать эффективные алгоритмы и структуры данных, а также улучшать качество программного обеспечения.
</content:encoded></item></channel></rss>